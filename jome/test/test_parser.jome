import * as assert from 'assert/strict'

import {parse} from '../src/parser.js'
import {tokenize} from '../src/tokenizer.js'

// Actually I don't really care about these tests. I don't want them. Only compile and end result.
// I don't care about the way they are implemented. Just the end result.
// TODO: Test inside test_compiler for each thing that can be chained that it works.

// I do care for priority of operations though, I think

describe "Parse operation" do

  it '1 + 2' do
    let list = parse(tokenize("1+2").children)
    assert.equal(list?.length, 1)
    let ast = list[0]
    assert.equal(ast?.raw, '+')
    assert.equal(ast?.operands?.[0]?.raw, '1')
    assert.equal(ast?.operands?.[1]?.raw, '2')
  end

  it '2 + 3 * 4 + 5 == 19' do
    let list = parse(tokenize("2 + 3 * 4 + 5 == 19").children)
    assert.equal(list?.length, 1)
    let ast = list[0]
    assert.equal(ast?.raw, '==')
    assert.equal(ast?.operands?.[0]?.raw, '+')
    assert.equal(ast?.operands?.[0]?.operands?.[0]?.raw, '+')
    assert.equal(ast?.operands?.[0]?.operands?.[0]?.operands?.[0]?.raw, '2')
    assert.equal(ast?.operands?.[0]?.operands?.[0]?.operands?.[1]?.raw, '*')
    assert.equal(ast?.operands?.[0]?.operands?.[0]?.operands?.[1]?.operands?.[0]?.raw, '3')
    assert.equal(ast?.operands?.[0]?.operands?.[0]?.operands?.[1]?.operands?.[1]?.raw, '4')
    assert.equal(ast?.operands?.[0]?.operands?.[1]?.raw, '5')
    assert.equal(ast?.operands?.[1]?.raw, '19')
  end
end

def validatePart(part, expected, msg)
  if (expected.type)
    assert.equal(part.type, expected.type, msg)
  end
  if (expected.value)
    assert.equal(part.value, expected.value)
  end
  if (expected.parts)
    if (part.parts.length !== expected.parts.length)
      let a = JSON.stringify(part.parts.map(p => p.type))
      let e = JSON.stringify(expected.parts.map(p => p.type))
      assert.equal(a, e, msg+".parts")
    end
    expected.parts.forEach do |e, i|
      validatePart(part.parts[i], e, msg+".parts[{i}]")
    end
  end
  if (expected.operands)
    assert.equal(part.operands.length, expected.operands.length, msg+".operands.length")
    expected.operands.forEach do |e, i|
      validatePart(part.operands[i], e, msg+".operands[{i}]")
    end
  end
end

def testParse(code, expected)
  let list = parse(tokenize(code).children)
  assert.equal(list.length, expected.length, "Number of expressions")
  expected.forEach do |e, i|
    validatePart(list[i], e, "Expression[{i}]")
  end
end

describe "Parse let assignment" do

  it 'let x' do
    testParse('let x', [{
      type: 'meta.declaration.jome',
      parts: [{type: 'keyword.control.declaration.jome'}, {type: 'variable.other.jome'}]
    }])
  end

  it 'let x;' do
    testParse('let x;', [
      {
        type: 'meta.declaration.jome',
        parts: [{type: 'keyword.control.declaration.jome'}, {type: 'variable.other.jome'}]
      },
      {type: 'punctuation.terminator.statement.jome'}
    ])
  end

  it 'let x; let y' do
    let list = parse(tokenize("let x; let y").children)
    assert.equal(list?.length, 3)
    assert.equal(list[0]?.raw, 'let x')
    assert.match(list[2]?.raw, /let y/)
  end

  it '[1][0]' do
    let list = parse(tokenize("[1][0]").children)
    assert.equal(list?.length, 1)
    let ast = list[0]
    assert.equal(ast?.parts?.length, 3) // [, 1, ]
    assert.equal(ast?.operands?.length, 1)
    assert.equal(ast?.operands?.[0]?.parts?.length, 3) // [, 0, ]
  end

end

describe "Parse conditions" do

  it 'if statements blocks, operation condition' do
    testParse('if x === 1\n  #log("hello")\nend', [{
      type: 'meta.if-block.jome',
      parts: [
        {type: 'keyword.control.conditional.jome'},
        {
          type: 'keyword.operator.comparison.jome'
          operands: [{type: 'variable.other.jome', type: 'constant.numeric.integer.jome'}]
        },
        {
          type: 'support.function-call.jome'
          parts: [{type: 'string.quoted.double.jome'}]
        },
        {type: 'keyword.control.jome'}
      ]
    }])
  end
  
end
