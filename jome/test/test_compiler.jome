import * as assert from 'assert/strict'

import {compileCode} from '../src/compiler.js'

def compile(code)
  return compileCode(code, {writeScript: false})
end

def testCompile(code, expectedResult)
  // FIXMEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE it code do is not being parsed properly...
  return do
    assert.match(compile(code), expectedResult);
  end
end


// FIXMEEE Nested string does not work, it escapeds the nested string...
// let tabs = "<div>
//     {contentByTitle.#keys.map(title => "<div>{title}</div>")}
//   </div>";




describe "Paths" do
  it 'Dirname shortcuts' do
    testCompile(`#.`, /__dirname/);
    testCompile(`#./`, /__dirname/);
    // compile(`#.`).#assertMatch(/__dirname/);
    // compile(`#./`).#assertMatch(/__dirname/);
  end
  it 'Absolute paths' do
    testCompile(`#/`, /"\/"/);
    testCompile(`#/some/path.ext`, /"\/some\/path\.ext"/);
  end
  it 'Path relative to current file' do
    testCompile(`#./some_file.ext`, /path.join\(__dirname, "some_file\.ext"\)/);
  end
  it 'Path relative to the current working directory' do
    testCompile(`#cwd/some_file.ext`, /path.resolve\("\.\/some_file\.ext"\)/);
  end
  it 'Path in the current file parent folder' do
    testCompile(`#..`, /path.join\(__dirname, ".."\)/);
    testCompile(`#../`, /path.join\(__dirname, "..\/"\)/);
    testCompile(`#../some_file.ext`, /path.join\(__dirname, "..\/some_file\.ext"\)/);
  end
  // I am not yet sure if I want to support this. It would be nice, but maybe #~ could be used for something else? Like signals?
  it.skip 'Path in the home directory' do
    testCompile(`#~`, /require\('os'\); os.homedir\(\)/);
    testCompile(`#~/`, /require\('os'\); os.homedir\(\)/);
    testCompile(`#~/some_file.ext`, /require\('os'\); path.join\(os.homedir\(\), 'some_file.ext'\)/);
  end
end




// TODO: Test import with ampersand to mean class import

describe "Imports" do
  it 'Default import Jome file' do
    testCompile(`import execute from "execute.jome"`, /const execute = require\("execute.js"\)/);
  end
  it 'Default import' do
    testCompile(`import name from "module-name"`, /const (\w+) = require\("module-name"\);\s*const name = \1.default;/);
    //testCompile(`import name from "module-name"`, /const name = require\("module-name"\)/);
  end
  it 'Star import' do
    testCompile(`import * as name from "module-name"`, /const name = require\("module-name"\)/);
    //testCompile(`import * as name from "module-name"`, /const (\w+) = require\("module-name"\);\s*const { ?default: \w+, ...name ?} = \1;/);
  end
  it 'Deconstructed import' do
    testCompile(`import { name } from "module-name"`, /const { ?name ?} = require\("module-name"\)/);
    testCompile(`import { name, name2 } from "module-name"`, /const { ?name, name2 ?} = require\("module-name"\)/);
  end
  it 'Alias deconstructed import' do
    testCompile(`import { name as otherName } from "module-name"`, /const { name: otherName } = require\("module-name"\)/);
    testCompile(`import { normal, name as otherName } from "module-name"`, /const { normal, name: otherName } = require\("module-name"\)/);
  end
  it 'Alias deconstructed import with default' do
    testCompile(`import def, { name as otherName } from "module-name"`, /const (\w+) = require\("module-name"\);\s*const { ?default: def, name: otherName ?} = \1;/);
  end

  // import { "string name" as alias } from "module-name";
  // FIXME: Is this valid or not? I saw online yes but it does not seem to work in vscode...
  // it 'Import name inside string' do
  // end

  it 'Default import and deconstructed' do
    testCompile(`import name, { foo } from "module-name"`, /const (\w+) = require\("module-name"\);\s*const { ?default: name, foo ?} = \1;/);
  end
  it 'Default import and star import' do
    // testCompile(`import name, * as all from "module-name"`, /const all = require\("module-name"\);\s*const { ?default: name?} = all;/);
    testCompile(`import name, * as all from "module-name"`, /const (\w+) = require\("module-name"\);\s*const { ?default: name, ...all ?} = \1;/);
  end
  // import "module-name"; TODO: Not written yet in the parser



  describe "Common JS imports" do
    it 'Import all' do
      testCompile(`import name : "module-name"`, /const name = require\("module-name"\);/);
    end
    it 'Import deconstructed' do
      testCompile(`import { foo, bar } : "module-name"`, /const { ?foo, ?bar ?} = require\("module-name"\);/);
    end
  end
end
// TODO: Test imports when compiling for ESM.




describe "Strings" do
  // Single quote strings should be compiled as is
  it 'Single quote strings' do
    // Note: Prettier replaces the string with double quotes
    testCompile(`'hello Éric'`, /"hello Éric"/);
    testCompile(`let code = 'if (cond) {return 0;}'`, /let code = "if \(cond\) {return 0;}"/);
    // Single quotes are allowed to be multiline in Jome
    testCompile(`'multi
    line'`, /`multi\s+line`/);
    // Test escapes double quotes inside
    testCompile(`'"hello"'`, /"\\"hello\\""/);
    // Test escapes backticks inside
    testCompile(`'multi \`line\`
    with backticks'`, /`multi \\`line\\`\s+with backticks`/);
  end
  it 'Regular double quote strings' do
    testCompile('"hello"', /"hello"/);
    testCompile(`"Hello Éric!"`, /"Hello Éric!"/);
    // Double quotes are allowed to be multiline in Jome
    testCompile(`"multi
    line"`, /`multi\s+line`/);
    testCompile(`"Hello O'Connor"`, /"Hello O'Connor"/);
    // Test escapes backticks inside
    testCompile(`"multi \`line\`
    with backticks"`, /`multi \\`line\\`\s+with backticks`/);
  end
  it 'Double quote strings template literal' do
    testCompile(`"1 + 1 = {1+1}"`, /`1 \+ 1 = \$\{1 ?\+ ?1\}`/);
  end
  it 'Triple single quote strings' do
    // Note: Prettier replaces the string with double quotes
    testCompile(`'''Hello O'Connor'''`, /"Hello O'Connor"/);
  end
  // TODO: Test """ Triple double quote strings """
  // TODO: Test """ Triple double quote strings template literals {{ foo }} """
  // TODO: Test @"Verbatim string" Test all 4 possibilities! (@'', @"", @''', @""")
end




// Regexes should work, the textmate grammar was copy pasted from the javascript one.
describe "Regexes" do
  it '/test1212/', testCompile(`/test1212/`, /\/test1212\//)
end




describe "Heredocs" do
  it '<sh>ls</sh>' do
    testCompile(`<sh>ls</sh>`, /const execSh = require\("@jome\/core\/execSh"\);\s*execSh\("ls"\);/);
  end
  describe "Heredoc percent syntax" do
    it '"ls"%sh' do
      testCompile(`"ls"%sh`, /const execSh = require\("@jome\/core\/execSh"\);\s*execSh\("ls"\);/);
    end
  end
end




describe "Comments" do
  describe "Documentation comments" do
    it 'Documentation comments should be compiled into js comments' do
      testCompile(`# documentation comment`, /\/\/ documentation comment/);
    end
  end
end





describe "Test arrow call" do
  it 'obj->call' do
    testCompile(`obj->call`, /obj.call\(\)/);
  end
end




describe "Test function call" do
  it 'Function call with parens' do
    testCompile(`
let add = (x,y) => x + y
add(10, 5)
`, /\s*let add = \(x, ?y\) => \(?x \+ y\)?;?\s*add\(10, ?5\);?/);
  end
  it 'Function call without parens' do
    testCompile(`
let add = (x,y) => x + y
add 10, 5
`, /\s*let add = \(x, ?y\) => \(?x \+ y\)?;?\s*add\(10, ?5\);?/);
  end
  it 'Function call without parens with entry' do
    testCompile(`
let idle = (options) => 10
idle delay: 20
`, /\s*let idle = \(options\) => \(10\)?;?\s*idle\(\{delay: ?20\}\);?/);
  end
end






describe "Test class" do
  it 'Class with one method' do
    testCompile(`
class Person
  def sayHello
    #log("Hello!")
  end
end
`, /\s*class Person\s*\{\s+sayHello = \(\) => \{\s*console.log\("Hello!"\);?\s*\};?\s*\}/);
  end
end






describe "Test built-ins" do
  it '#keys', testCompile('#keys({})', /Object.keys\(\{\}\)/)
  it '#values', testCompile('#values({})', /Object.values\(\{\}\)/)
  it '#entries', testCompile('#entries({})', /Object.entries\(\{\}\)/)
  it '#argv', testCompile('#argv', /process.argv/)
  it '#PI', testCompile('#PI', /Math.PI/)
  it '#global', testCompile('#global', /globalThis/)
  it '#env', testCompile('#env', /process.env/)
  it '#log', testCompile('#log', /console.log/)

  it '#log hello world' do
    testCompile('#log("Hello world!")', /console.log\("Hello world!"\)/);
  end
  it '#log hello world without parens' do
    testCompile('#log "Hello world!"', /console.log\("Hello world!"\)/);
  end
  it '{x:1}.#log' do
    testCompile('{x:1}.#log', /console.log\(\{ ?x\: ?1 ?\}\);?/);
  end
end





describe "Creating functions" do
  /*
  The keyword def generates an arrow function. The keyword fn generates a function.
  You can also use the let keyword instead of def
  Functions can also be declared inline.
  */
  // def sayHello
  // end
  // let sayHello = function
  // end
  // let sayHello = function(name)
  // end
  // def sayHello(name)
  // end
  // let sayHello = (name) => `Hello {name}`
  // let giveMe5 = () => 5
  // and/or
  // let giveMe5 = => 5
  // *** KEYWORD def ***
  it 'def keyword' do
    testCompile('def sayHello #log("hello") end', /function sayHello\(\) {\s*console.log\("hello"\);?\s*}/);
  end
  it 'def keyword with args' do
    testCompile('def sayHello(name) #log("hello", name) end', /function sayHello\(name\) {\s*console.log\("hello", ?name\);?\s*}/);
  end
  // *** KEYWORD let ***
  it 'let keyword with function end' do
    testCompile('let sayHello = function #log("hello") end', /let sayHello = function \(\) {\s*console.log\("hello"\);?\s*}/);
  end
  it 'let keyword with function end with args' do
    testCompile('let sayHello = function(name) #log("hello", name) end', /let sayHello = function \(name\) {\s*console.log\("hello", ?name\);?\s*}/);
  end
  it 'let keyword with arrow function' do
    testCompile('let giveMe5 = () => 5', /let giveMe5 = \(\) => \(?5\)?/);
  end
  it 'let keyword with arrow function with args' do
    testCompile('let echo = (x) => x', /let echo = \(x\) => \(?x\)?/);
  end
  // *** inline ***
  it 'inline with function end' do
    testCompile('let f = function #log("hello") end', /let f = function \(\) {\s*console.log\("hello"\);?\s*}/);
  end
  it 'inline with function end with args' do
    testCompile('let f = function(x, name) #log("hello", name) end', /let f = function \(x,\s*name\) {\s*console.log\("hello", ?name\);?\s*}/);
  end
  it 'inline with arrow function' do
    testCompile('() => 5', /\(\) => \(?5\)?/);
  end
  it 'inline with arrow function with args no paren' do
    testCompile('x => x', /\(?x\)? => \(?x\)?/);
  end
  it 'inline with arrow function with args' do
    testCompile('(x) => x', /\(x\) => \(?x\)?/);
  end
  // *** KEYWORD do ***
  it 'let keyword with do end' do
    testCompile('let sayHello = do #log("hello") end', /let sayHello = function \(\) {\s*console.log\("hello"\);?\s*}/);
  end
  it 'let keyword with do end with args' do
    testCompile('let sayHello = do |name| #log("hello", name) end', /let sayHello = function \(name\) {\s*console.log\("hello", ?name\);?\s*}/);
  end

  describe "With curly braces" do
    // TODO: (curly braces are always right before a closing parenthesis)
    // let f = () => {return 10}
    // let f = function () {return 10}
    // let f = fn () {return 10}
    // let f = fn () {return 10}
    // class Foo bar() {return 10} end
    // class Foo void bar() {return 10} end       MAYBE
    // class Foo bar() : void {return 10} end     MAYBE
    // class Foo bar() -> void {return 10} end    MAYBE

    /*
    class Foo
      bar()
      // Is bar a function call or a new function?
      bar() {

      }
    end
    */

    /*
    Ouin simplement supporter cela. Fuck sayHello() {]
    def sayHello {
      #log "Hello!"
    }
    Nooon ne pas supporter cette syntaxe. Avec def c'est toujours end.

    // Ce n'est pas le plus beau, mais c'est pratique et explicit ainsi.
    // C'est mieux en avant que loin après les nombreux paramères
    // Ouin work in progress....
    def void sayHello { }
    def sayHello hello end
    // THIS DOES NOT WORK... This syntax would require parentheses...

    // With fn it can work because fn requires parentheses contrary to def
    fn void sayHello() {

    }

    c'est un peu bizarre d'utiliser fn dans une classe par contre je trouve

    class Foo

      @foo = 10 // allowed
      
      // Maybe only assignments are allowed inside a class?
      // The rest must be inside constructor
      def constructor // No params here if they are specified before the class Foo
      end

      // I want to be able to do:

      void doSomething() {

      }

      // I don't want to do inside a class:

      fn void doSomething() {

      }


      # It is said that this function does something
      # @attr arg1 The number arg1
      # @attr arg2 The number arg2
      # @returns The result of doSomething
      void doSomething(int arg1, int arg2) {
        // ...
      }


      // Also I'd like it to be similar to js, I'd like to support even if I don't like it much

      doSomething() {

      }

    end

    Outside a class, then use (like javascript)

    fn void doSomething() {

    }

    Outside a class the keyword fn is required to defined a new function, like in javascript.
    */

    it 'inline with arrow function with args' do
      testCompile('(x) => x', /\(x\) => \(?x\)?/);
    end
  end
end




describe "Test if statements" do
  it 'if statements blocks' do
    testCompile('if true #log("hello") end', /\s*if \(true\) \{\s*console.log\("hello"\);?\s*\}/);
  end
  // An if modifier executes everything to it's left only if the condition is true
  it 'if modifier' do
    testCompile('let x; x = "10" if true', /let x;\s*if \(?true\)? \{\s*x = "10";?\s*\}/);
  end
  it 'if statements blocks with elsif and else' do
    testCompile(`if true
  x = 1
elsif false
  x = 2
else
  x = 3
end
`, /\s*if \(true\) \{\s*x = 1;\s*\} else if \(false\) \{\s*x = 2;\s*\} else \{\s*x = 3;\s*\}/);
  end
end




describe "Test attribute accessor" do
  it '({x:5}).x' do
    testCompile('({x:5}).x', /\(\{ ?x\: ?5 ?\}\)\.x/);
  end
  it 'let o; o.x' do
    testCompile('let o; o.x', /let o;\s*?o\.x;?/);
  end

  describe "Optional attribute accessor" do
    it 'let o; o?.x' do
      testCompile('let o; o?.x', /let o;\s*?o\?\.x;?/);
    end
    it 'let o; o?.x?.y' do
      testCompile('let o; o?.x?.y', /let o;\s*?o\?\.x\?\.y;?/);
    end
  end
end





describe "Test attribute setter" do
  it 'let o; o.x = 10' do
    testCompile('let o; o.x = 10', /let o;\s*?o\.x ?= ?10;?/);
  end
end





describe "Values" do
  it 'integer' do
    testCompile('10', /10/)
    testCompile('1234', /1234/)
  end
  it 'float' do
    testCompile('1.0', /1.0/)
    testCompile('12.34', /12.34/)
  end

  describe "Language constant values" do
    it 'true', testCompile('true', /true/)
    it 'false', testCompile('false', /false/)
    it 'null', testCompile('null', /null/)
    it 'undefined', testCompile('undefined', /undefined/)
  end

  describe "Arrays" do
    it '[]', testCompile('[]', /\[\]/)
    it '[1,2,3]', testCompile('[1,2,3]', /\[1, ?2, ?3\]/)
  end
end





describe "Types" do
  describe "Variable declaration" do
    describe "Default types with type before" do
      it 'int', testCompile('int x', /let x/)
      it 'int assignment', testCompile('int x = 0', /let x = 0/)
      it 'float', testCompile('float x', /let x/)
      it 'float assignment', testCompile('float x = 1.0', /let x = 1\.0/)
      it 'string', testCompile('string x', /let x/)
      it 'string assignment', testCompile('string x = "hello"', /let x = "hello"/)
      it 'bool', testCompile('bool x', /let x/)
      it 'bool assignment', testCompile('bool x = true', /let x = true/)
      it 'int[]', testCompile('int[] x', /let x/)
      it 'int[] assignment', testCompile('int[] x = [1,2,3]', /let x = \[1, ?2, ?3\]/)
      // TODO: SomeClass
      // TODO: Array<int>
      // TODO: SomeClass<int> are templates allowed???
    end
    describe "Default types with type after" do
      it 'int', testCompile('let x : int', /let x/)
      it 'int assignment', testCompile('let x : int = 0', /let x = 0/)
      it 'float', testCompile('let x : float', /let x/)
      it 'float assignment', testCompile('let x : float = 1.0', /let x = 1\.0/)
      it 'string', testCompile('let x : string', /let x/)
      it 'string assignment', testCompile('let x : string = "hello"', /let x = "hello"/)
      it 'bool', testCompile('let x : bool', /let x/)
      it 'bool assignment', testCompile('let x : bool = true', /let x = true/)
      it 'int[]', testCompile('let x : int[]', /let x/)
      it 'int[] assignment', testCompile('let x : int[] = [1,2,3]', /let x = \[1, ?2, ?3\]/)
      // TODO: SomeClass
      // TODO: Array<int>
      // TODO: SomeClass<int> are templates allowed???
    end
  end
end
// Support these?
// let decimal: number = 6;
// let hex: number = 0xf00d;
// let binary: number = 0b1010;
// let octal: number = 0o744;
// let big: bigint = 100n;

// FIXME: tuple
// [string, number] x = ["ten", 10]
// maybe keyword primitive type tuple?
// tuple<string, number> x = ["ten", 10]

// void

/*
I want to do the same for function types too. They replace the keyword def.

int sum(int x, int y)
  // ...
end

class SomeClass
  int someMethod(int x, int y)
    // ...
  end
  void doSomething
    // ...
  end
end
*/





describe "Test objects" do
  it '({})', testCompile('({})', /\(\{\}\)/)
  it '{x: 1}', testCompile('{x: 1}', /\{\s*x\: ?1;?\s*\}/)
  it '{x: 1, y: 2}', testCompile('{x: 1, y: 2}', /\{\s*x\: ?1, y: 2\s*\}/)
  it 'key is quoted string', testCompile('{"x": 1}', /\{\s*x\: ?1;?\s*\}/)
end






describe 'No group' do
  it 'Test each do end' do
    testCompile(`
  [1,2,3,4,5].each do |i|
    console.log i
  end
  `, /\s*\[1, 2, 3, 4, 5\]\.each\(function \(i\) \{\s*console\.log\(i\);?\s*\}\)\s*/);
  end
  it 'Pass named parameters to functions' do
    testCompile(`add x: 1, y: 2`, /add\(\{ x: 1, y: 2 \}\)/);
  end

  it 'let shouldAddSemiToDec = 1' do
    assert.match(compile(`let shouldAddSemiToDec = foo()[0]`, {prettier: false}), /;\s*$/);
  end
end





describe 'Assignment' do
  it 'let x = 1' do
    // FIXME: Do I want var or I want let? I used var because it is what CoffeeScript is using by default.
    testCompile('let x = 1', /(var|let)\s+x\s*=\s*1/);
  end
end





describe 'Operations' do
  describe 'Inversion (! operator)' do
    it '!true', testCompile('!true', /!true/)
    it '!true === false', testCompile('!true === false', /!true === false/)
    it '!true === !false', testCompile('!true === !false', /!true === !false/)
    it '!true === !!false', testCompile('!true === !!false', /!true === !!false/)
  end
  describe 'Mathematic operations' do
    it 'addition' do
      testCompile('1 + 2', /1 \+ 2/);
      testCompile('1 + 2 + 3', /1 \+ 2 \+ 3/);
    end
    it 'multiplication' do
      testCompile('1 * 2', /1 \* 2/);
      testCompile('1 * 2 * 3', /1 \* 2 \* 3/);
    end
    it 'division' do
      testCompile('8 / 2', /8 \/ 2/);
      testCompile('8 / 4 / 2', /8 \/ 4 \/ 2/);
    end
    it 'substraction' do
      testCompile('8 - 2', /8 \- 2/);
      testCompile('8 - 2 - 3', /8 \- 2 \- 3/);
    end
  end
  describe 'Priority of operations' do
  end
end





describe 'Test "ternary"' do
  it 'true ? 1', testCompile('true ? 1', /true \? 1 : null/)
  // C'est quand même plus beau cond ? val1 : val2
  it 'false ? 1 : 0', testCompile('false ? 1 : 0', /false \? 1 : 0/)
end





describe 'async' do
  // TODO: async, await
end