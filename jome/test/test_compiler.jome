import assert from 'assert/strict'

import MiniSpec from 'minispec'
import { describe, it } from 'minispec'

import {compileCode} from '../src/compiler.js'

def compile(code)
  return compileCode(code, {writeScript: false})
end

describe "Paths" do
  it 'Dirname shortcuts' do
    assert.match(compile(`#.`), /__dirname/);
    assert.match(compile(`#./`), /__dirname/);
  end
  it 'Absolute paths' do
    assert.match(compile(`#/`), /"\/"/);
    assert.match(compile(`#/some/path.ext`), /"\/some\/path\.ext"/);
  end
  it 'Path relative to current file' do
    assert.match(compile(`#./some_file.ext`), /path.join\(__dirname, "some_file\.ext"\)/);
  end
  it 'Path relative to the current working directory' do
    assert.match(compile(`#cwd/some_file.ext`), /path.resolve\("\.\/some_file\.ext"\)/);
  end
  it 'Path in the current file parent folder' do
    assert.match(compile(`#..`), /path.join\(__dirname, ".."\)/);
    assert.match(compile(`#../`), /path.join\(__dirname, "..\/"\)/);
    assert.match(compile(`#../some_file.ext`), /path.join\(__dirname, "..\/some_file\.ext"\)/);
  end
  // I am not yet sure if I want to support this. It would be nice, but maybe #~ could be used for something else? Like signals?
  // it 'Path in the home directory' do
  //   assert.match(compile(`#~`), /require\('os'\); os.homedir\(\)/);
  //   assert.match(compile(`#~/`), /require\('os'\); os.homedir\(\)/);
  //   assert.match(compile(`#~/some_file.ext`), /require\('os'\); path.join\(os.homedir\(\), 'some_file.ext'\)/);
  // end
end

describe "Imports" do
  // import defaultExport from "module-name";
  it 'Default import' do
    assert.match(compile(`import name from "module-name"`), /const name = require\("module-name"\)/);
  end
  // import * as name from "module-name";
  it 'Star import' do
    assert.match(compile(`import * as name from "module-name"`), /const (\w+) = require\("module-name"\);\s*const { ?default: \w+, ...name ?} = \1;/);
  end
  // import { export1 } from "module-name";
  // import { export1, export2 } from "module-name";
  it 'Deconstructed import' do
    assert.match(compile(`import { name } from "module-name"`), /const { ?name ?} = require\("module-name"\)/);
    assert.match(compile(`import { name, name2 } from "module-name"`), /const { ?name, name2 ?} = require\("module-name"\)/);
  end
  // import { export1 as alias1 } from "module-name";
  // import { export1, export2 as alias2, /* … */ } from "module-name";
  it 'Alias deconstructed import' do
    assert.match(compile(`import { name as otherName } from "module-name"`), /const {name as otherName} = require\("module-name"\)/);
    assert.match(compile(`import { normal, name as otherName } from "module-name"`), /const {normal, name as otherName} = require\("module-name"\)/);
  end
  // import { default as alias } from "module-name";
  it 'Alias deconstructed import' do
    assert.match(compile(`import { name as otherName } from "module-name"`), /const {name as otherName} = require\("module-name"\)/);
  end
  // import { "string name" as alias } from "module-name";
  // FIXME: Is this valid or not? I saw online yes but it does not seem to work in vscode...
  // it 'Import name inside string' do
  // end
  // import defaultExport, { export1, /* … */ } from "module-name";
  it 'Default import and deconstructed' do
    assert.match(compile(`import name, { foo } from "module-name"`), /const (\w+) = require\("module-name"\);\s*const { ?default: name, foo ?} = \1;/);
  end
  // import defaultExport, * as name from "module-name";
  it 'Default import and star import' do
    assert.match(compile(`import name, * as all from "module-name"`), /const (\w+) = require\("module-name"\);\s*const { ?default: name, ...all ?} = \1;/);
  end
  // import "module-name"; TODO: Not written yet in the parser
end
// TODO: Test imports when compiling for ESM.

MiniSpec.execute()
