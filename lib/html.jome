// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
// TODO: The ARIA role attribute and the multiple aria-* states and properties, used for ensuring accessibility.
// TODO: The event handler attributes: onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting.
interface GlobalAttributes |
  accesskey?,
  autocapitalize?,
  autofocus?,
  class?,
  contenteditable?,
  dir?,
  draggable?,
  enterkeyhint?,
  hidden?,
  id?,
  inert?,
  inputmode?,
  is?,
  itemid?,
  itemprop?,
  itemref?,
  itemscope?,
  itemtype?,
  lang?,
  nonce?,
  part?,
  popover?,
  role?,
  slot?,
  spellcheck?,
  style?,
  tabindex?,
  title?,
  translate?,
  virtualkeyboardpolicy?,
|

def renderHTMLAttrs = |obj| => (
  var r = obj->signals->keys.map(n =>
    `on{n}="jome.run('${obj->path}.{n}()')"`
  ).join(" ")

  // FIXME: Needs a space between signals and props

  r = r + (obj->props->entries.filter(entry => (entry[0] != 'css')).map(entry =>
    `{entry[0]}="{entry[1]}"`
  ).join(" "))

  r = r + (obj->hasOwnProperty('css') ? ('style="'+obj.css->entries.map(entry => `{entry[0]}: {entry[1]}`).join('; ')+'"') : '')

  r ? (' '+r) : r
)

def renderHTMLChildren = |obj| => (
  obj->children.map(c => (c.toString ? c.toString() : '')).join("")
)

def renderHTML = |obj, target?| => (
  var elem = document.getElementById(target)
  children = []
  html = ''
  obj->children.forEach(child => (
    if (child.createElem) (
      var e = child.createElem()
      children.push(e)
    ) else if (child.toString) (
      html += child.toString()
    )
  ))
  elem.innerHTML = html
  children.forEach(child => (
    elem.appendChild(child)
  ))
)

// FIXME: List given by LLM and not verified
HTML_EVENTS = [
  "click",
  "dblclick",
  "mouseover",
  "mouseout",
  "mousedown",
  "mouseup",
  "mousemove",
  "contextmenu",
  "keydown",
  "keyup",
  "keypress",
  "submit",
  "reset",
  "change",
  "focus",
  "blur",
  "input",
  "touchstart",
  "touchend",
  "touchmove",
  "touchcancel",
  "load",
  "unload",
  "resize",
  "scroll",
  "play",
  "pause",
  "ended",
  "volumechange",
  "timeupdate",
  "dragstart",
  "drag",
  "dragenter",
  "dragleave",
  "dragover",
  "drop",
  "dragend",
  "animationstart",
  "animationend",
  "animationiteration",
  "transitionstart",
  "transitionend"
]

class Html {
  ~run: => (
    document.getElementById(target).innerHTML = renderHTMLChildren(@)
  )
}

// ns: namespace for createElementNS
def createElem = |obj, tag, content, ns| => (
  var el = (ns ? document.createElementNS(ns, tag) : document.createElement(tag))
  if (content) (
    el.appendChild(document.createTextNode(content))
  )
  obj->props->entries.filter(entry => (entry[0] != 'css')).forEach(entry => (
    el.setAttribute(entry[0], entry[1])
  ))
  if (obj.css) (
    el.style= obj.css->entries.map(entry => `{entry[0]}: {entry[1]}`).join('; ')
  )
  obj->children.forEach(child => (
    if (child.createElem) (
      el.appendChild(child.createElem())
    ) else if (child.toString) (
      tmp = document.createElement("div")
      tmp.innerHTML = child.toString()
      console.log('here', tmp.innerHTML)
      el.appendChild(tmp.firstElementChild)
    )
  ))
  obj->signals->keys.forEach(n => (
    if (HTML_EVENTS.includes(n)) (
      el.addEventListener(n, obj['~'+n])
    )
  ))
  el
)

class Tag |tag, content| => {
  toString: => `<{tag}{renderHTMLAttrs(@)}>{content||''}{renderHTMLChildren(@)}</{tag}>`
  createElem: => createElem(@, tag, content)
}
class InlineTag |tag| => {
  toString: => `<{tag}{renderHTMLAttrs(@)} />`
  createElem: => createElem(@, tag)
}
class Fragment => {
  toString: => `{renderHTMLChildren(@)}`
  createElem: => (
    var el = document.createDocumentFragment()
    @->children.forEach(child => (
      if (child.createElem) (
        el.appendChild(child.createElem())
      )
    ))
    el
  )
}

export class H1 |text, &GlobalAttributes| => { super: Tag "h1", text }
class H2 text => { super: Tag "h2", text }
class H3 text => { super: Tag "h3", text }
class P text => { super: Tag "p", text }
class Li text => { super: Tag "li", text }
class Span text => { super: Tag "span", text }
export class Div text => { super: Tag "div", text }
class Pre text => { super: Tag "pre", text }
class Code text => { super: Tag "code", text }

class Form { super: Tag "form" }
class Ul { super: Tag "ul" }
class Ol { super: Tag "ol" }
class HtmlObject { super: Tag "object" }
class Canvas { super: Tag "canvas" }

class Br { super: InlineTag "br" }
class Hr { super: InlineTag "hr" }

class Txt text => {
  toString: => (
    attrs = renderHTMLAttrs(@)
    attrs ? "<span{attrs}>{text}</span>" : "{text}"
  )
  createElem: => (
    document.createTextNode(text)
  )
}
class Btn text => { super: Tag "button", text }
Button = Btn
class Link |url, name| => { super: Tag "a", name, href: url }

class Label |name, text| => { super: Tag "label", text, htmlFor: text }

class Input |name| => { super: InlineTag "input", id: name, name: name, autocomplete: name }
class Img |url, alt| => { super: InlineTag "img", src: url, alt: alt }
