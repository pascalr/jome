import {AppPage} from './app.jome'

<css>
  pre {
    background-color: #dce0e8;
    padding: 1em;
    border-radius: 8px;
  }
  code:not(pre code) {
    background-color: #dce0e8;
    padding: 0.5em;
    border-radius: 8px;
  }
</css>

«
  AppPage title: 'Simple HTML Page', content: (<md>

  # Jome

  Jome is a language that compiles in JavaScript. It is simliar to CoffeeScript in this way.

  You can read from top to bottom to learn the language, or you can jump to any section if you are only curious.

  ## Features

  Main ideas:
  - [Nodes](#nodes) - An object in a tree structure
  - [Integrated scripts](#integrated-scripts) - Incoroporate code from other languages
  - [Named parameters](#named-parameters) - Add optional parameters easily
  - [Instance driven development](#instance-driven-dev) - A more approchable way to programming

  Goodies / Syntaxic sugar:
  - [Arrow getter](#arrow-getter) - Allows to save keystrokes and is easier to type. ex: obj->keys => Object.keys(obj)
  - Optional let - Not sure about that one...
  - [Verbatim string literals](#verbatim) - @\`This is a string that does ${not} interpolate\`
  - [Units](#units) - You can add units to numbers. ex: "density = 105g / 98mL"

  ## Overview

  Example Jome code:
  ```jome
  import {Btn, Txt, renderHTML} from "html"

  // Add a button to the main scene ($) which has a text as a children
  $ <<
    Btn @count: 0, ~click: => (@count += 1)
      Txt => "Clicked {@count} {@count == 1 ? 'time' : 'times'}"
  >>

  // Compile all the objects of the scene and write the html to #jome-placeholder div
  renderHTML($, target: 'jome-placeholder')
  ```

  Example compiled JavaScript output:
  ```js
  import jome from 'jome_lib'
  import {Btn, Txt, renderHTML} from "html"

  var $ = jome.createObj()
  var btn

  // Add a button to the scene which has a text as a children
  btn = new Btn({__signal__click: () => {this.count += 1}})
  btn.count = 0
  jome.createObj($, btn)
  jome.createObj($.$.$btn, new Txt(() => (
    `Clicked ${this.count} ${this.count == 1 ? 'time' : 'times'}`
  )))

  // Compile all the objects of the scene and write the html to #jome-placeholder div
  renderHTML({target: 'jome-placeholder'}, $)
  ```

  ## Disclaimer

  The language is very, very young and still contains a log of bugs. Also, I did not study in computer science. I am just a random hvac technician that somehow ended up writing a programming language. I may be doing a lot of things stupidly. Please be nice and correct me in a constructive manner if so.


  ## Installation

  TODO

  ## Usage

  TODO: Expliquer comment compiler du code .jome en code JavaScript.

  <h2 id="lang-ref">Language Reference</h2>

  There is two main modes in the language.

  Code mode: This is very similar to JavaScript, with a few distinction. Blocks are delimited using parentheses instead of curly braces {}. Curly
  braces are only used for dictionaries (JavaScript objects) and in some others cases like imports.

  Object mode: Object blocks delimited by « » or << >> use indentation to make a tree of objects. «» is for an orphan object which has not parent.
  << >> is used to push objects as a children to an existing object.

  $ is the main object
  $foo/bar is a path to get the children of the main object named foo, and then get it's children named bar

  `$ << $foo >>` => add an object named foo inside the main object '$'

  ### Functions

  TODO: Ajouter les functions -> à jome. Il doit y avoir un espace avant le -> pour que ce soit une fonction. Sinon, c'est le meta accessor.

  ### Scripts

  In jome, the idea is that you could include most other programming languages directly using xml tags.

  ```jome
  // Execute a shell command in a script
  <sh>ls -A</sh>

  // Ruby is a pretty nice language for scripts too 
  <rb>puts (1..10).select(&:even?).sum</rb>
  ```

  #### Scripts interpolation

  You can add data inside the scripts using the < % =    % > syntax.

  Contrary to other template languages like ejs, you must finish the expression given inside the interpolation tag.

  If you want to do a condition for example, you use a nesting tag < > ... < / >

  < % = if true < >
    <div class="content">
      < % = content % >
    </div>
  else < >
    <div class="content">
      < % = content % >
    </div>
  < / > % >

  The behavior will depend on the kind of script.

  On html, it will insert a template literal interpolation.

  On markdown what do I want to do?

  Logically, it would include markdown. But this mean that some markdown would be compiled at compile time,
  and that the text inside the interpolation would be compiled at run time. I don't like this because I don't
  want the built file to include the javascript of markdown-it. But this could be a feature if that is actually
  what the user want.

  But right now, I am the user and this is not what I want. So what I want is that the text to be interpolated
  be removed from the markdown compile, and that inserted compiled using a template literal.

  Basically, I want to inject html and not inject markdown directly.

  <h2 id="verbatim-strings">Verbatim Strings</h2>

  Like in C#. @"foo \ $ blahblah bar" => directly with no interpolation

  <h2 id="nodes">Nodes</h2>

  A node is an object that can have children. It is a nice structure to build trees. It is often useful for example when working with HTML. 

  ```jome
  import {Btn, Txt, renderHTML} from "html"

  // Add a button to the main scene ($) which has a text as a children
  $ <<
    Btn @count: 0, ~click: => (@count += 1)
      Txt => "Clicked {@count} {@count == 1 ? 'time' : 'times'}"
  >>

  // Compile all the objects of the scene and write the html to #jome-placeholder div
  renderHTML($, target: 'jome-placeholder')
  ```

  <h2 id="arrow-getter">Arrow getter</h2>

  Allows to save keystrokes and is easier to type.
  Allows to easily use most of underscore.js features directly.

  ```jome
  // Arrow getter is useful for objects
  dict = {x: 10, y: 20}
  dict->keys // Object.keys(obj)
  dict->size // Object.keys(obj).length

  // Arrow getter is useful for nodes
  node = «
    $parent
      $child1
      $child2
  »
  node->children

  // Arrow getter is useful for arrays
  TODO
  ```

  <h2 id="instance-driven-dev">Instance driven development</h2>
  Instance driven development is what I call when the focus is working on concrete objects in Godot software.
  Most of the time you control objects directly inside the editor and simply modify parameters.
  
  It's the same thing as object oriented, but the focus is on the concrete object rather than the abstract class.

  <h2 id="integrated-scripts">Integrated scripts</h2>

  <h2 id="named-parameters">Named parameters</h2>

  <h2 id="units">Units</h2>

  You can add units at the end of numbers like 100g. You can also add units at the end of variables using the middle dot.

  This feature is not yet implemented. Right now, it does nothing. The idea, is that if you have a function for example sleep
  that takes a time, then you can give it 1s or 1000ms or 0.000ks and it would all do the same thing.

  I want everything to be handled at compile time. I don't want to create a datastructure for this.

  Also, it's just nice to be able to write a unit beside a number.

  An idea also is that I would like to add an operator like variable->unit => which gives the unit has a string.
  So this way, you have the number for the variable directly, but if the program can infer the unit of the variable,
  you can also get it's unit.

  density = 105g / 98mL
  density->unit => "g/mL"

  area = 2m * 3m
  area->unit => "m^2"

  maybe, for an argument to a function, well it could be anything, so you either specify what unit you are expecting,
  or maybe have a special construct that means that you want the variable and it's unit

  func = |anything| => anything->unit
  func(10g)
  // because we are asking for unit here, it means that two args must actually be passed to the function, anything and __unit__anything
  so it would be compiled to
  function func(anything, __unit__anything) {

  }
  func(10, "g")

  <h2 id="verbatim">Verbatim string literals</h2>

  Verbatim string literals - @\`This is a string that does ${not} interpolate\`





  ## Thrash

  It's intented main purpose is to be used for prototyping or small projects. It is usefull for concrete applications like making something visual.

  ## Acknowledgements

  TODO: Explain why

  - CoffeeScript: I was kinda lost at some point. I did not have a clear direction for my language. Until I thought, hey, coffeescript did something similar! So it gave me a lot of guidance.
  - underscore.js: A great library full of goodies.
  - vscode: Escpecially thank you for creating custom grammar. It is really nice to create a grammar and see live the tokenization.

  Thank you to everyone who contributed to any open-sourced library. Escpecially under a license like MIT license. You are awesome!

  TODO: Link to the librairies website

  Librairies used:
  - express
  - markdown-it

</md>)
».print()