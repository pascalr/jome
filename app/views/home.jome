import {AppPage} from '../lib/app.jome'

main {
  AppPage title: 'Simple HTML Page', content: (<md>

  # Jome

  Jome is a language that compiles in JavaScript. It is simliar to CoffeeScript in this way.

  You can read from top to bottom to learn the language, or you can jump to any section if you are only curious.

  ## Overview

  Example Jome code: TODO: Make this like the examples so you can click see compiled and result

  Here is some code to show what Jome looks like. You can look at the [examples](/examples) page to see more.

  ```jome
  // Classes
  class Character |@name, @weapon?| => {
    attack: |enemy| => (

    )
  }
  class Weapon |damage?, range?| => {}

  // Inheritence and properties
  class Dagger { super: Weapon range: 50 }
  class WeakDagger { super: Dagger damage: 50 }
  class StrongDagger { super: Dagger damage: 200 }

  // Instantiation
  var startingWeapon = { WeakDagger }
  var hero = { Character "Paul", weapon: startingWeapon }

  // Scripts (any language, here shell)
  var gameSaved = <sh>cat "saved-gamed.json"</sh>

  // Functions
  def announceGameIsStarted = -> (
    console.log('Game started!')
  )
  announceGameIsStarted()
  ```
  
  ## Disclaimer

  The language is very, very young and still contains a log of bugs. I don't recommend using yet for any real project.

  I don't have a list of bugs yet, because there are too many.

  ## Installation

  ```sh
  # FIXME: NPM PACKAGE IS NOT YET CREATED!
  npm install jome
  ```

  ## Usage

  ```sh
  # Usage
  jomec # compiles based on jomeconfig.json
  jomec "file.jome" # compile the given file and it's dependencies
  jomec "views/*.jome" # compile all the files that matches the path and their dependencies
  ```

  For more information, see the [compiling page](/compiling)

  <h2 id="lang-ref">Language Reference</h2>

  This documentation assumes the reader is familiar with javascript.

  Jome is similar to JavaScript, but there are a few distinctions that you must be aware of. Mainly, the syntax is a bit different, there are nodes, named parameters and scripts.

  <h2 id="syntax">Syntax</h2>

  Parentheses are used for statement blocks.

  ```jome
  if (someCondition) (
    /* Notice the usage of parentheses and not curly braces */
  )
  ```

  Curly braces are used for [blocks](#blocks).

  ```jome
  def someFunction = -> (return 10 + 20) // ok
  def someFunction = -> {return 10 + 20} // WRONG!
  def someFunction = -> {x: 10} // ok
  ```



  Vertical bars are used for function parameters.
  ```jome
  def addXY = |x, y| -> (x + y)
  ```

  ### Keywords

  Declaration keywords:
  - [var](#declaration): To declare variables
  - [def](#declaration): To declare functions
  - [let](#declaration): To declare anything

  ### Bilingual

  Jome is bilingual in french and english. There are french keywords equivalent to english keywords.

  - vrai: true
  - faux: false
  - si: if
  - sinon: else
  - requiert: require
  - ...

  <h2 id="blocks">Blocks</h2>

  Blocks are a key component of Jome. They use indentation to build objects in a short and subjectively pretty way.
  It is also the syntax required to build [nodes](#nodes).

  Blocks are surrounded by curly braces. The result of a block can be an object, a list, a node or a value.

  ```jome
  // objects
  position = {x: 10, y: 10}
  destination = {
    x: 40
    y: 50
  }
  details = {
    distanceX: 30, distanceY: 40 // comma is optional
    totalDistance: 50, eta: 10min
  }

  // lists
  numbers = {1,2,3,4} // but [1,2,3,4] is preferred when on a single line
  names = {
    "Jean"
    "Jacques"
    "Paul"
  }
  matrix = {
    1, 0, 0
    0, 1, 0
    0, 0, 1
  }

  // nodes
  node = {
    Obj some: 'obj'
      'String child'
      Nested prop: 'val'
  }

  // values
  singleObj = {Obj prop: 'val'}
  chainResult = {
    Obj prop: 'val'
      Nested prop: 'val'
        Nested prop: 'val'
      run
  } // The value will be the result of the function run of the object created.
  ```

  ### Shorthand key syntax

  The short key syntax is different that in javascript, because it could be confused with list. In Jome, it starts with a colon
  ```jome
  obj = {:content, :value}
  // same as
  obj = {content: content, value: value}
  ```

  ### Functions inside blocks

  A variable name nested under a node is a function call.

  If you want to refer to the variable to add it as a children, you use the = sign at the beginning.

  ```jome
  // Create a server, add a get handler and start it
  {
    ExpressServer port: 3000
      get '/', |req, res| => (
        res.send(homePage)
      )
      start
  }

  obj = {
    Obj prop: 'val'
      =addChild('arg')
      executeFunction
  }
  ```

  ### List with single element

  In a block, you can't have a list with a single element because it that case it returns the element directly.
  You have to use the square brackets syntax then.

  <h2 id="nodes">Nodes</h2>

  Nodes are objects in a tree structure. They can have a parent and they can have children.

  You create nodes by using blocks.

  ```jome
  node = {
    Obj (
      prop: 'val',
      prop2: 'val2'
    )
      @attr = 'val3'
      @attr2 = 'val4'
      child: 'val5'
      child2: 'val6'
  }
  ```

  ### Adding children to nodes
  
  In order to add children to nodes, you can use the << operator.

  ```jome
  hero.inventory << {
    Sword damage: 10, weight: 500g
    Shield armor: 8, weight: 400g
    Scroll "Scroll of wisdom"
    Belt
      HealingPotion life: 200
      ManaPotion mana: 100
  }
  ```

  ### Children attached with key

  LES NODES N'ONT PAS DE NOM, MAIS TU PEUX LES ATTACHER AVEC UNE CLÉ À UN PARENT
  QUAND TU ATTACHES UN CHILDREN AVEC UNE CLÉ, il est là ET il est dans la liste de children.
  si tu veux mettre à un attribute, mais pas children, alors utiliser @attr
 
  ```jome
  $ <<
    someVar = 10
    page: Page
      navbar: Navbar
        list: List
          Link "Musics", to: '/musics'
          Link "Sports", to: '/sports'
          Link "Arts", to: '/arts'
      Body
        Txt < md >
          # Welcome
          Welcome to this website! You can browse links at the top.
        < / md>
  >>
  var navLinks = $page.navbar.list->children
  ```

  ### Under the hood

  Underneath, nodes are objects with a property named '$'. The idea of doing it this way is in order to not clash with user defined properties for
  example name.

  The property includes the following attributes:
  - children: The list of children of the node.
  - parent: A link to the node who is it's parent
  - signals: A list of the signals the node listens to
  - childrenCount: The number of children of the node. Not sure about this one. TODO: Remove this since I can do children.length

  <h2 id="named-parameters">Named parameters and props</h2>

  When calling a function, you can add paramters.

  ```jome
  someFunc(someParam: 10, otherParam: 'Jean')
  ```

  To define parameters when creating a function, you either add ? at the end for an optional parameter, or you add ! for a required parameter.

  ```jome
  def someFunc = |someParam?, otherParam? = 'Pierre', optionalParam?, requiredParam!| => (
    console.log(someParam) // No need to add ? or ! when refering to a parameter
  )
  ```

  You can pass a parameter that was not defined in the list.

  BUT YOU CAN'T PASS a parameter to a function if the function does not take any parameter. Because under the hood,
  we add a params argument to the function, so we need at least one to add the argument, then you can pass as many as you want.

  When calling a function with named parameters, the order does not matter. You can put them before arguments, after or even in the middle.

  ### Props

  Props are the specific case of object creation. When you pass parameters when creating an object, we call them props.

  ```jome
  « Obj someProp: 10, otherProp: 'Paul' »
  ```

  ### Under the hood

  TODO: Explain how it works

  ## Classes

  ### Inheritence

  ```jome
    class Base {
      super: Abstract prop: 'val'
    }
  ```

  ## Interfaces

  An interface is a list of props. When you declare a class, you can give an interface so you don't have to specify every time the list of
  possible parameters that can be given.

  To refer to an interface, you add an ampersand before the name.

  ```jome
  interface HtmlOptions |
    width?,
    height?
  |

  class Div &HtmlOptions => {/* ... */}
  class Span |arg, &HtmlOptions| => {/* ... */}
  ```

  ### Functions

  Il doit y avoir un espace avant le -> pour que ce soit une fonction. Sinon, c'est le meta accessor.

  By default, Jome adds returns statements to functions. This setting can be disabled in the config file.

  It is very nice when prototyping to not have to write return statements. But for production code, it is safer to always write them, this
  way you never return by accident a sensitive value that should be hiden from users.

  <h2 id="scripts">Scripts</h2>

  In jome, the idea is that you could include most other programming languages directly using xml tags.

  ```jome
  // Execute a shell command in a script
  <sh>ls -A</sh>

  // Ruby is a pretty nice language for scripts too 
  <rb>puts (1..10).select(&:even?).sum</rb>
  ```

  ### Scripts interpolation

  You can add data inside the scripts using the < % =    % > syntax.

  Contrary to other template languages like ejs, you must finish the expression given inside the interpolation tag.

  If you want to do a condition for example, you use a nesting tag < > ... < / >

  ```jome
  < % = if true < >
    <div class="content">
      < % = content % >
    </div>
  else < >
    <div class="content">
      < % = content % >
    </div>
  < / > % >
  ```

  The behavior will depend on the kind of script.

  On html, it will insert a template literal interpolation.

  On markdown what do I want to do?

  Logically, it would include markdown. But this mean that some markdown would be compiled at compile time,
  and that the text inside the interpolation would be compiled at run time. I don't like this because I don't
  want the built file to include the javascript of markdown-it. But this could be a feature if that is actually
  what the user want.

  But right now, I am the user and this is not what I want. So what I want is that the text to be interpolated
  be removed from the markdown compile, and that inserted compiled using a template literal.

  Basically, I want to inject html and not inject markdown directly.

  ### .jobj extension

  Files with a .jobj extension would start already in a block.

  It think this would be pratical for example for config files.

  <h2 id="arrow-getter">Arrow getter</h2>

  Allows to save keystrokes and is easier to type.
  Allows to easily use most of underscore.js features directly.

  ```jome
  // Arrow getter is useful for objects
  dict = {x: 10, y: 20}
  dict->keys // Object.keys(obj)
  dict->size // Object.keys(obj).length

  // Arrow getter is useful for nodes
  node = «
    $parent
      $child1
      $child2
  »
  node->children

  // Arrow getter is useful for arrays
  TODO

  // TODO
  10->times(i => /* ... */)
  ```

  <h2 id="instance-driven-dev">Instance driven development</h2>
  Instance driven development is what I call when the focus is working on concrete objects in Godot software.
  Most of the time you control objects directly inside the editor and simply modify parameters.
  
  It's the same thing as object oriented, but the focus is on the concrete object rather than the abstract class.

  <h2 id="units">Units</h2>

  ```jome
  debug = |arg, unit argUnit| => (
    /* ... */
  )
  ```

  You can add units at the end of numbers like 100g. You can also add units at the end of variables using the middle dot.

  This feature is not yet implemented. Right now, it does nothing. The idea, is that if you have a function for example sleep
  that takes a time, then you can give it 1s or 1000ms or 0.000ks and it would all do the same thing.

  I want everything to be handled at compile time. I don't want to create a datastructure for this.

  Also, it's just nice to be able to write a unit beside a number.

  An idea also is that I would like to add an operator like variable->unit => which gives the unit has a string.
  So this way, you have the number for the variable directly, but if the program can infer the unit of the variable,
  you can also get it's unit.

  density = 105g / 98mL
  density->unit => "g/mL"

  area = 2m * 3m
  area->unit => "m^2"

  maybe, for an argument to a function, well it could be anything, so you either specify what unit you are expecting,
  or maybe have a special construct that means that you want the variable and it's unit

  func = |anything| => anything->unit
  func(10g)
  // because we are asking for unit here, it means that two args must actually be passed to the function, anything and __unit__anything
  so it would be compiled to
  function func(anything, __unit__anything) {

  }
  func(10, "g")

  <h2 id="verbatim">Verbatim string literals</h2>

  Verbatim string literals are strings that do not interpolate. The idea is taken from C#. But in C# it also includes backslashes without escaping
  them I don't know if I want to do that. Or I want to offer multiple possibilities.
  
  ```jome
  str = @"This is a string that does ${not} interpolate"
  ```

  ## signals
  
  Signals are used for events. They are not very much implemented yet. TODO: Check how Godot handles events, check how js handles events.

  In Jome, signals start with a tilde.

  ```jome
  class Button {
    ~click() {
      console.log('Button clicked!')
    }
  }

  btn = « Button »
  btn.click()
  ```

  <h2 id="declaration">Declaration</h2>

  When you declare a variable without a keyword, the variable will be a constant. To declare a variable, use the var keyword.
  To declare a function, use de def function.

  TODO: Keywords, var, def, let

  ```jome
  PI = 3.1415
  PI = 10 // ERROR. PI is not allowed to be redeclared anywhere nested inside the scope
  var x = 10
  x = 20
  def add10 = x => x + 10
  add10(20)
  add10 = x => x + 20 // ERROR. add10 can only be redeclared in a nested scope
  ```

  ## Capture de code

  TODO: Quelque chose que j'aimerais beaucoup avoir. Un système pour capturer le code.

  Par exemple,

  ```jome
  nomDeVariable = 10
  debug = |arg, code argCode| => (
    console.log("Debugging {argCode}: Value {arg}")
  )
  debug(nomDeVariable) // => Debugging nomDeVariable: Value 10
  ```

  ## Main

  The `main` keyword is compiled to `export default`.

  ## Contributing

  I recommend using visual studio code for now because it is super usefull for debugging tokenization. You hit Ctrl+Shift+P,
  "inspect editor token and scope", and you see if it is correct. Also you see using syntax highlighting.

  You can make pull requests on github.

  You can simply make constructive comments on github.

  Keep in mind I am working only 10 hours a week on this project for now.

  ## Acknowledgements

  TODO: Explain why

  - CoffeeScript: I was kinda lost at some point. I did not have a clear direction for my language. Until I thought, hey, coffeescript did something similar! So it gave me a lot of guidance.
  - underscore.js: A great library full of goodies.
  - vscode: Escpecially thank you for creating custom grammar. It is really nice to create a grammar and see live the tokenization.
  - ChatGPT: I probably never would have had to courage to go through with writing a programming language if I did not have the help from ChatGPT.

  Thank you to everyone who contributed to any open-sourced library. Escpecially under a license like MIT license. You are awesome!

  TODO: Link to the librairies website

  Librairies used:
  - express
  - markdown-it

  ## Thrash  

  It's intented main purpose is to be used for prototyping or small projects. It is usefull for concrete applications like making something visual.

    «
    Page
      Navbar
        List
          Link "Musics", to: '/musics'
          Link "Sports", to: '/sports'
          Link "Arts", to: '/arts'
      Body
        Txt < md >
          # Welcome
          Welcome to this website! You can browse links at the top.
        < / md>
  »

    Il est aussi possible de définir des variables dans un bloc. Les variables sont simplement sorties du block et exécuter avant le bloc.


  Avoir un keyword new ou ben simplement toujours utiliser les blocks?
  ```jome
  obj = new Obj(/* ... */) // Supporter new?
  obj = {Obj /* ... */}
  ```

  The advantage is that there is never confusion. You never have an error that tells you you have to add parentheses. For example, in javascript:

  ```js
  let someFunction = () => ({x: 10}) // you often have to add extra parentheses around objects in js
  ```

  ## Features

  Main ideas:
  - [Nodes](#nodes) - An object in a tree structure
  - [Integrated scripts](#integrated-scripts) - Incoroporate code from other languages
  - [Named parameters and props](#named-parameters) - Add optional parameters easily
  - [Instance driven development](#instance-driven-dev) - A more approchable way to programming

  Goodies / Syntaxic sugar:
  - [Arrow getter](#arrow-getter) - Allows to save keystrokes and is easier to type. ex: obj->keys => Object.keys(obj)
  - Optional let - Not sure about that one...
  - [Verbatim string literals](#verbatim) - @\`This is a string that does ${not} interpolate\`
  - [Units](#units) - You can add units to numbers. ex: "density = 105g / 98mL"
  - [Hyphen](#hyphens) - You can use hyphens in variable names like left-panel. The minus operator should always be surrounded by spaces.

</md>)
}.toString()