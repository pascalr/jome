import {AppPage} from '../lib/app.jome'

«
  AppPage title: 'Simple HTML Page', content: (<md>

  # Jome

  Jome is a language that compiles in JavaScript. It is simliar to CoffeeScript in this way.

  You can read from top to bottom to learn the language, or you can jump to any section if you are only curious.

  ## Overview

  Example Jome code: TODO: Make this like the examples so you can click see compiled and result

  ```jome
  // Classes
  class Character |@name, @weapon?| => {
    attack: |enemy| => (

    )
  }
  class Weapon |damage?, range?| => {}

  // Inheritence and properties
  class Dagger « Weapon range: 50 »
  class WeakDagger « Dagger damage: 50 »
  class StrongDagger « Dagger damage: 200 »

  // Instantiation
  var startingWeapon = « WeakDagger »
  var hero = « Character "Paul", weapon: startingWeapon »

  // Scripts (any language, here shell)
  var gameSaved = <sh>cat "saved-gamed.json"</sh>

  // Functions
  def announceGameIsStarted = -> (
    console.log('Game started!')
  )
  announceGameIsStarted()
  ```
  
  ## Disclaimer

  The language is very, very young and still contains a log of bugs. Also, I did not study in computer science. I am just a random hvac technician that somehow ended up writing a programming language. I may be doing a lot of things stupidly. Please be nice and correct me in a constructive manner if so.


  ## Installation

  ```sh
  # FIXME: NPM PACKAGE IS NOT YET CREATED!
  npm install jome
  ```

  ## Usage

  ```sh
  # Usage
  jomec # compiles based on jomeconfig.json
  jomec "file.jome" # compile the given file and it's dependencies
  jomec "views/*.jome" # compile all the files that matches the path and their dependencies
  ```

  For more information, see the [compiling page](/compiling)

  <h2 id="lang-ref">Language Reference</h2>

  This documentation assumes the reader is familiar with javascript.

  Jome is similar to JavaScript, but there are a few distinctions that you must be aware of. Mainly, the syntax is a bit different, there are nodes, named parameters and scripts.

  <h2 id="syntax">Syntax</h2>

  Parentheses are used for statement blocks.

  ```jome
  if (someCondition) (
    /* Notice the usage of parentheses and not curly braces */
  )
  ```

  Curly braces are used for javascript objects (aka dictionaries).

  ```jome
  def someFunction = -> (return 10 + 20) // ok
  def someFunction = -> {return 10 + 20} // WRONG!
  def someFunction = -> {x: 10} // ok
  ```

  The advantage is that there is never confusion. You never have an error that tells you you have to add parentheses. For example, in javascript:

  ```js
  let someFunction = () => ({x: 10}) // you often have to add extra parentheses around objects in js
  ```

  Vertical bars are used for function parameters.
  ```jome
  def addXY = |x, y| -> (x + y)
  ```

  ### Keywords

  You use `var` for variables and `def` for functions.

  TODO: Say more

  Maybe allow the let keyword that works for both var and def?

  The advantage of def and var is that you know what the thing is.

  But when prototyping, who cares, you can just use let.

  I think def is nice to use for functions.

  Oui accepter le keyword let, il est beaucoup plus beau que var. C'est
  juste que j'aimais que var soit multilingue. Mais let est plus beau.

  <h2 id="blocks">Blocks</h2>

  Blocks are surrounded by curly braces and use indentation. The result of a block can be an object, a list, a node or a value.

  ```jome
  // objects
  position = {x: 10, y: 10}
  destination = {
    x: 40
    y: 50
  }
  details = {
    distanceX: 30, distanceY: 40 // comma is optional
    totalDistance: 50, eta: 10min
  }

  // lists
  numbers = {1,2,3,4} // but [1,2,3,4] is preferred when on a single line
  names = {
    "Jean"
    "Jacques"
    "Paul"
  }
  matrix = {
    1, 0, 0
    0, 1, 0
    0, 0, 1
  }

  // nodes
  node = {
    Obj some: 'obj'
      'String child'
      Nested prop: 'val'
  }

  // values
  singleObj = {Obj prop: 'val'}
  chainResult = {
    Obj prop: 'val'
      Nested prop: 'val'
        Nested prop: 'val'
      .run()
  } // The value will be the result of the function run of the object created.
  ```

  ### Shorthand key syntax

  The short key syntax is different that in javascript, because it could be confused with list. In Jome, it starts with a colon
  ```jome
  obj = {:content, :value}
  // same as
  obj = {content: content, value: value}
  ```

  ### Functions inside blocks

  To call a function inside a block, you either call it with parentheses or you add an equal sign at the beginning.

  ```jome
    names = {
      generateRandomName(seed: 546072384425) // functions can be called with parentheses
      =generateRandomName seed: 945701924554 // functions can be called with an equal sign
    }
  ```

  ### Adding children to nodes
  
  In order to add children to nodes, you can use the << operator.

  ```jome
  $ << {
    Obj prop: 'val'
    Obj prop: 'val'
  }
  ```

  ### List with single element

  In a block, you can't have a list with a single element because it that case it returns the element directly.
  You have to use the square brackets syntax then.

  <h2 id="nodes">Nodes</h2>

  Nodes are objects in a tree structure. They can have a parent and they can have children.

  `$` is the root node. There is one root node by file.

  `$someNode` is a short syntax to get the child of the root node named "someNode".

  You create nodes by using blocks.

  ```jome
  alone = « Volleyball "Wilson", age: 2 »

  «
    Obj (
      prop: 'val',
      prop2: 'val2'
    )
      @attr = 'val3'
      @attr2 = 'val4'
      child: 'val5'
      child2: 'val6'
  »
  ```

  ### Children attached with key

  LES NODES N'ONT PAS DE NOM, MAIS TU PEUX LES ATTACHER AVEC UNE CLÉ À UN PARENT
  QUAND TU ATTACHES UN CHILDREN AVEC UNE CLÉ, il est là ET il est dans la liste de children.
  si tu veux mettre à un attribute, mais pas children, alors utiliser @attr

  ### Standalone node block

  You can create a single node by surrounding with guillements. There must be a single object at the top, and then children are created based on indentation.

  

  Idea: If adding guillemets is too hard for people with english keyboards, then allow the syntax:
  _<< >> which would be the same as « ».

  ### Children node block

  You can create and add directly children an existing node by surrounding with `<< >>`. The children are created based on indentation.

  ```jome
  $inventory <<
    Sword damage: 10, weight: 500g
    Shield armor: 8, weight: 400g
    Scroll "Scroll of wisdom"
    Belt
      HealingPotion life: 200
      ManaPotion mana: 100
  >>
  ```

  ### Node names

  FIXME: Pour le nom des objets, au lieu de $nomDeLobjet, je propose nomDeLobjet: ...
 
  ```jome
  $ <<
    someVar = 10
    page: Page
      navbar: Navbar
        list: List
          Link "Musics", to: '/musics'
          Link "Sports", to: '/sports'
          Link "Arts", to: '/arts'
      Body
        Txt < md >
          # Welcome
          Welcome to this website! You can browse links at the top.
        < / md>
  >>
  var navLinks = $page.navbar.list->children
  ```

  ### Under the hood

  Underneath, nodes are objects with a property named '$'. The idea of doing it this way is in order to not clash with user defined properties for
  example name.

  The property includes the following attributes:
  - name: The name of the node
  - children: The list of children of the node.
  - parent: A link to the node who is it's parent
  - signals: A list of the signals the node listens to
  - childrenCount: The number of children of the node. Not sure about this one. TODO: Remove this since I can do children.length

  <h2 id="named-parameters">Named parameters and props</h2>

  When calling a function, you can add paramters.

  ```jome
  someFunc(someParam: 10, otherParam: 'Jean')
  ```

  To define parameters when creating a function, you add the & symbol before the variable name.

  ```jome
  def someFunc = |&someParam, &otherParam = 'Pierre', &optionalParam| => (
    console.log(someParam) // No need to add & when refering to a parameter
  )
  ```

  Je me demandais si ça ne serait pas mieux la syntaxe avec un point d'interogation à la fin au lieu de & au début.
  L'avantage est de pouvoir combiner élégament avec les attributs. Comme ça dans une class tu peux spécifier que tu
  veux que la variable soit à donner dans le constructeur ou pas selon s'il y a un point d'interrogation.

  ```jome
  def someFunc = |someParam?, otherParam? = 'Pierre', optionalParam?| => (
    console.log(someParam) // No need to add & when refering to a parameter
  )
  ```

  Props are the specific case of object creation. When you pass parameters when creating an object, we call them props.

  ```jome
  « Obj someProp: 10, otherProp: 'Paul' »
  ```

  You can pass a parameter that was not defined in the list.

  BUT YOU CAN'T PASS a parameter to a function if the function does not take any parameter. Because under the hood,
  we add a params argument to the function, so we need at least one to add the argument, then you can pass as many as you want.

  ### Under the hood

  TODO: Explain how it works

  ## Classes

  ### Inheritence

  Classes inherit using the « » syntax. It is usefull

  ## Interfaces

  An interface is a list of props. When you declare a class, you can give an interface so you don't have to specify every time the list of
  possible parameters that can be given.

  ### Functions

  TODO: Ajouter les functions -> à jome. Il doit y avoir un espace avant le -> pour que ce soit une fonction. Sinon, c'est le meta accessor.

  By default, Jome adds returns statements to functions. This setting can be disabled in the config file.

  It is very nice when prototyping to not have to write return statements. But for production code, it is safer to always write them, this
  way you never return by accident a sensitive value that should be hiden from users.

  ### Scripts

  In jome, the idea is that you could include most other programming languages directly using xml tags.

  ```jome
  // Execute a shell command in a script
  <sh>ls -A</sh>

  // Ruby is a pretty nice language for scripts too 
  <rb>puts (1..10).select(&:even?).sum</rb>
  ```

  ### .jobj extension

  Files with a .jobj extension would start already in a node block.

  It think this would be pratical for example for config files.


  #### Scripts interpolation

  You can add data inside the scripts using the < % =    % > syntax.

  Contrary to other template languages like ejs, you must finish the expression given inside the interpolation tag.

  If you want to do a condition for example, you use a nesting tag < > ... < / >

  < % = if true < >
    <div class="content">
      < % = content % >
    </div>
  else < >
    <div class="content">
      < % = content % >
    </div>
  < / > % >

  The behavior will depend on the kind of script.

  On html, it will insert a template literal interpolation.

  On markdown what do I want to do?

  Logically, it would include markdown. But this mean that some markdown would be compiled at compile time,
  and that the text inside the interpolation would be compiled at run time. I don't like this because I don't
  want the built file to include the javascript of markdown-it. But this could be a feature if that is actually
  what the user want.

  But right now, I am the user and this is not what I want. So what I want is that the text to be interpolated
  be removed from the markdown compile, and that inserted compiled using a template literal.

  Basically, I want to inject html and not inject markdown directly.

  <h2 id="verbatim-strings">Verbatim Strings</h2>

  Like in C#. @"foo \ $ blahblah bar" => directly with no interpolation

  <h2 id="arrow-getter">Arrow getter</h2>

  Allows to save keystrokes and is easier to type.
  Allows to easily use most of underscore.js features directly.

  ```jome
  // Arrow getter is useful for objects
  dict = {x: 10, y: 20}
  dict->keys // Object.keys(obj)
  dict->size // Object.keys(obj).length

  // Arrow getter is useful for nodes
  node = «
    $parent
      $child1
      $child2
  »
  node->children

  // Arrow getter is useful for arrays
  TODO
  ```

  <h2 id="instance-driven-dev">Instance driven development</h2>
  Instance driven development is what I call when the focus is working on concrete objects in Godot software.
  Most of the time you control objects directly inside the editor and simply modify parameters.
  
  It's the same thing as object oriented, but the focus is on the concrete object rather than the abstract class.

  <h2 id="integrated-scripts">Integrated scripts</h2>

  <h2 id="units">Units</h2>

  ```jome
  debug = |arg, unit argUnit| => (
    /* ... */
  )
  ```

  You can add units at the end of numbers like 100g. You can also add units at the end of variables using the middle dot.

  This feature is not yet implemented. Right now, it does nothing. The idea, is that if you have a function for example sleep
  that takes a time, then you can give it 1s or 1000ms or 0.000ks and it would all do the same thing.

  I want everything to be handled at compile time. I don't want to create a datastructure for this.

  Also, it's just nice to be able to write a unit beside a number.

  An idea also is that I would like to add an operator like variable->unit => which gives the unit has a string.
  So this way, you have the number for the variable directly, but if the program can infer the unit of the variable,
  you can also get it's unit.

  density = 105g / 98mL
  density->unit => "g/mL"

  area = 2m * 3m
  area->unit => "m^2"

  maybe, for an argument to a function, well it could be anything, so you either specify what unit you are expecting,
  or maybe have a special construct that means that you want the variable and it's unit

  func = |anything| => anything->unit
  func(10g)
  // because we are asking for unit here, it means that two args must actually be passed to the function, anything and __unit__anything
  so it would be compiled to
  function func(anything, __unit__anything) {

  }
  func(10, "g")

  <h2 id="verbatim">Verbatim string literals</h2>

  Verbatim string literals are strings that do not interpolate. The idea is taken from C#. But in C# it also includes backslashes without escaping
  them I don't know if I want to do that. Or I want to offer multiple possibilities.
  
  ```jome
  str = @"This is a string that does ${not} interpolate"
  ```

  ## signals
  
  Signals are used for events. They are not very much implemented yet. TODO: Check how Godot handles events, check how js handles events.

  In Jome, signals start with a tilde.

  ```jome
  class Button {
    ~click() {
      console.log('Button clicked!')
    }
  }

  btn = « Button »
  btn.click()
  ```

  ## Declarations

  When you declare a variable without a keyword, the variable will be a constant. To declare a variable, use the var keyword.
  To declare a function, use de def function.

  ```jome
  PI = 3.1415
  PI = 10 // ERROR. PI is not allowed to be redeclared anywhere nested inside the scope
  var x = 10
  x = 20
  def add10 = x => x + 10
  add10(20)
  add10 = x => x + 20 // ERROR. add10 can only be redeclared in a nested scope
  ```

  ## Capture de code

  TODO: Quelque chose que j'aimerais beaucoup avoir. Un système pour capturer le code.

  Par exemple,

  ```jome
  nomDeVariable = 10
  debug = |arg, code argCode| => (
    console.log("Debugging {argCode}: Value {arg}")
  )
  debug(nomDeVariable) // => Debugging nomDeVariable: Value 10
  ```

  ## Acknowledgements

  TODO: Explain why

  - CoffeeScript: I was kinda lost at some point. I did not have a clear direction for my language. Until I thought, hey, coffeescript did something similar! So it gave me a lot of guidance.
  - underscore.js: A great library full of goodies.
  - vscode: Escpecially thank you for creating custom grammar. It is really nice to create a grammar and see live the tokenization.
  - ChatGPT: I probably never would have had to courage to go through with writing a programming language if I did not have the help from ChatGPT.

  Thank you to everyone who contributed to any open-sourced library. Escpecially under a license like MIT license. You are awesome!

  TODO: Link to the librairies website

  Librairies used:
  - express
  - markdown-it

  ## Thrash  

  It's intented main purpose is to be used for prototyping or small projects. It is usefull for concrete applications like making something visual.

    «
    Page
      Navbar
        List
          Link "Musics", to: '/musics'
          Link "Sports", to: '/sports'
          Link "Arts", to: '/arts'
      Body
        Txt < md >
          # Welcome
          Welcome to this website! You can browse links at the top.
        < / md>
  »

    Il est aussi possible de définir des variables dans un bloc. Les variables sont simplement sorties du block et exécuter avant le bloc.


  Avoir un keyword new ou ben simplement toujours utiliser les blocks?
  ```jome
  obj = new Obj(/* ... */) // Supporter new?
  obj = {Obj /* ... */}
  ```

  ## Features

  Main ideas:
  - [Nodes](#nodes) - An object in a tree structure
  - [Integrated scripts](#integrated-scripts) - Incoroporate code from other languages
  - [Named parameters and props](#named-parameters) - Add optional parameters easily
  - [Instance driven development](#instance-driven-dev) - A more approchable way to programming

  Goodies / Syntaxic sugar:
  - [Arrow getter](#arrow-getter) - Allows to save keystrokes and is easier to type. ex: obj->keys => Object.keys(obj)
  - Optional let - Not sure about that one...
  - [Verbatim string literals](#verbatim) - @\`This is a string that does ${not} interpolate\`
  - [Units](#units) - You can add units to numbers. ex: "density = 105g / 98mL"
  - [Hyphen](#hyphens) - You can use hyphens in variable names like left-panel. The minus operator should always be surrounded by spaces.

  ## Overview

  Example Jome code:
  ```jome
  import {Btn, Txt, renderHTML} from "html"

  // Add a button to the main scene ($) which has a text as a children
  $ <<
    Btn @count: 0, ~click: => (@count += 1)
      Txt => "Clicked {@count} {@count == 1 ? 'time' : 'times'}"
  >>

  // Compile all the objects of the scene and write the html to #jome-placeholder div
  renderHTML($, target: 'jome-placeholder')
  ```

  Example compiled JavaScript output:
  ```js
  import jome from 'jome_lib'
  import {Btn, Txt, renderHTML} from "html"

  var $ = jome.createObj()
  var btn

  // Add a button to the scene which has a text as a children
  btn = new Btn({__signal__click: () => {this.count += 1}})
  btn.count = 0
  jome.createObj($, btn)
  jome.createObj($.$.$btn, new Txt(() => (
    `Clicked ${this.count} ${this.count == 1 ? 'time' : 'times'}`
  )))

  // Compile all the objects of the scene and write the html to #jome-placeholder div
  renderHTML({target: 'jome-placeholder'}, $)
  ```


</md>)
».toString()