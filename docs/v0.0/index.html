
      <!DOCTYPE html>
      <HTML lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Jome</title>
          <link rel="stylesheet" type="text/css" href="/jome/stylesheet.css">
          <link rel="stylesheet" type="text/css" href="/jome/highlight.js.min.css">
          <link rel="stylesheet" type="text/css" href="/jome/hljs_tomorrow_night_bright.css">
          <link rel="apple-touch-icon" sizes="180x180" href="/jome/apple-touch-icon.png">
          <link rel="icon" type="image/png" sizes="32x32" href="/jome/favicon-32x32.png">
          <link rel="icon" type="image/png" sizes="16x16" href="/jome/favicon-16x16.png">
          <link rel="manifest" href="/jome/site.webmanifest">
        </head>
        <body>
          <div class="d-flex flex-column" style="min-height: 100vh;">
          
  <div class="navbar">
    <a class="navbrand" href="/jome/" style="margin-left: 4em;">Jome</a>
    <span style="flex-grow: 2;"></span>
    <a href="/jome/getting_started">Getting started</a>
    <a href="/jome/ref">Language Reference</a>
    <a href="/jome/ex">Examples</a>
    <a href="/jome/jome_lib">JomeLib</a>
    <a href="/jome/in_depth">In depth</a>
    <a href="/jome/editor">Editor</a>
    <a href="https://github.com/pascalr/jome">GitHub</a>
    <span style="flex-grow: 1;"></span>
  </div>
          <div style="flex-grow: 1; height: calc(100vh - 50px);">
            <div class="d-flex" style="height: 100%;">
            
  <div id="left-nav" class="scrollable">
    <ul class="nav-list">
      <li><a href="/jome/">Home</a></li>
      <ul class="nav-list nav-sub">
        <li><a href="/jome/#overview">Overview</a></li>
        <li><a href="/jome/#features">Features</a></li>
      </ul>
      <li><a href="/jome/getting_started">Getting started</a></li>
      <ul class="nav-list nav-sub">
        <li><a href="/jome/getting_started/#install">Install</a></li>
        <li><a href="/jome/getting_started/#usage">Usage</a></li>
        <li><a href="/jome/getting_started/#hello-world">Hello world</a></li>
        <li><a href="/jome/getting_started/#index-jome">index.jome</a></li>
        <li><a href="/jome/getting_started/#config-jome">config.jome</a></li>
        <li><a href="/jome/getting_started/#createjomeapp">createjomeapp</a></li>
      </ul>
      <li><a href="/jome/ref">Language Reference</a></li>
      <ul class="nav-list nav-sub">
        <li><a href="/jome/ref/#syntax">Syntax</a></li>
        <ul class="nav-list nav-sub-sub">
          <li><a href="/jome/ref/#keywords">Keywords</a></li>
          <li><a href="/jome/ref/#comments">Comments</a></li>
        </ul>
        <li><a href="/jome/ref/#builtins">Built-Ins</a></li>
        <li><a href="/jome/ref/#strings">Strings</a></li>
        <ul class="nav-list nav-sub-sub">
          <li><a href="/jome/ref/#formatting">Formatting</a></li>
          <li><a href="/jome/ref/#heredocs">Heredocs</a></li>
          <li><a href="/jome/ref/#paths">Paths</a></li>
        </ul>
        <li><a href="/jome/ref/#conditions">Conditions</a></li>
        <li><a href="/jome/ref/#loops">Loops</a></li>
        <li><a href="/jome/ref/#switch-case">Switch/Case</a></li>
        <li><a href="/jome/ref/#with">With keyword</a></li>
        <li><a href="/jome/ref/#classes">Classes</a></li>
        <ul class="nav-list nav-sub-sub">
          <li><a href="/jome/ref/#formatting">Instance properties (@)</a></li>
        </ul>
        <li><a href="/jome/ref/#exports">Modules and exports</a></li>
        <li><a href="/jome/ref/#along">Along keyword</a></li>
        <li><a href="/jome/ref/#threads">Threads</a></li>
        <li><a href="/jome/ref/#private">Private</a></li>
        <li><a href="/jome/ref/#env">Environment variables</a></li>
        <li><a href="/jome/ref/#global">Global variables</a></li>
        <li><a href="/jome/ref/#chain">Chain</a></li>
        <li><a href="/jome/ref/#contributing">Contributing</a></li>
        <li><a href="/jome/ref/#ack">Acknowledgements</a></li>
      </ul>
      <li><a href="/jome/ex">Templates and Examples</a></li>
      <ul class="nav-list nav-sub">
        <li><a href="/jome/ex/TODO">Basic (TODO: Hello world)</a></li>
        <li><a href="/jome/ex/TODO">Static website (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Web server (TODO)</a></li>
        <li><a href="/jome/ex/TODO">MVC server (TODO)</a></li>
        <li><a href="/jome/ex/TODO">React (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Vue (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Svelte (TODO)</a></li>
        <li><a href="/jome/ex/TODO">2d game (TODO: Snake)</a></li>
        <li><a href="/jome/ex/TODO">3d game (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Android app (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Ios app (TODO)</a></li>
        <li><a href="/jome/ex/TODO">Command line tool (TODO)</a></li>
      </ul>
      <li><a href="/jome/in_depth">In depth</a></li>
      <ul class="nav-list nav-sub">
        <li><a href="/jome/TODO">createjomeapp</a></li>
        <li><a href="/jome/TODO">config.jome</a></li>
        <li><a href="/jome/TODO">CLI</a></li>
        <li><a href="/jome/formats">Formats</a></li>
        <li><a href="/jome/lib">Librairies</a></li>
        <ul class="nav-list nav-sub-sub">
          <li><a href="/jome/lib/html">Html</a></li>
          <li><a href="/jome/lib/html-layout">Html Layout</a></li>
          <li><a href="/jome/lib/express-server">Express Server</a></li>
        </ul>
      </ul>
    </ul>
  </div>
            <div class="scrollable" style="width: 100%;">
              <div class="main">
                <h1>Jome v-0.0</h1>
<p>Jome is a language that compiles to JavaScript. It has a node structure like in Godot, types like Typescript,
goodies like CoffeeScript and underscore.js, syntax similar to ruby, it handles state like in React and it
has some original features.......</p>
<p>Well that's the idea at least. Right now it is very much in experimental phase. There are a lot of bugs and not many tests are written yet.</p>
<p>You can read from top to bottom to learn the language, or you can jump to any section if you are only curious.</p>
<h2>Overview</h2>
<p>Example Jome code: TODO: Make this like the examples so you can click see compiled and result</p>
<p>Here is some code to show what Jome looks like. You can look at the <a href="/jome/examples">examples</a> page to see more.</p>
<pre><code class="language-jome"><span class="hljs-keyword">with</span>
  name: <span class="hljs-type">string</span>
  weapon: <span class="hljs-variable">Weapon</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Character</span>(<span class="hljs-variable">@name</span>)
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-variable">enemy</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">interface</span> <span class="hljs-variable">CharacterProps</span>
  name: <span class="hljs-type">string</span>
  weapon: <span class="hljs-variable">Weapon</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Character</span>(<span class="hljs-variable">@name</span>) &lt; <span class="hljs-variable">CharacterProps</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-variable">enemy</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Classes</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Character</span>(<span class="hljs-variable">@name</span>, <span class="hljs-variable">props</span>)
  <span class="hljs-variable">include</span> <span class="hljs-variable">props</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-variable">enemy</span>)

  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Character</span>(<span class="hljs-variable">name</span>, <span class="hljs-variable">props</span>)
  <span class="hljs-variable">@name</span> = <span class="hljs-variable">name</span>
  <span class="hljs-variable">@weapon</span> = <span class="hljs-variable">props</span>.<span class="hljs-variable">weapon</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(<span class="hljs-variable">enemy</span>)

  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">interface</span> <span class="hljs-variable">Weapon</span>
  damage: <span class="hljs-variable">number</span>
  range: <span class="hljs-type">int</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// When you inherit from an interface, you can call super on the interface to initialize some values</span>

<span class="hljs-comment">// Inheritence and properties</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Dagger</span> &lt; <span class="hljs-title function_">Weapon</span>(range: <span class="hljs-number">50</span>) <span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">WeakDagger</span> &lt; <span class="hljs-title function_">Dagger</span>(damage: <span class="hljs-number">50</span>) <span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">StrongDagger</span> &lt; <span class="hljs-title function_">Dagger</span>(damage: <span class="hljs-number">200</span>) <span class="hljs-keyword">end</span>

<span class="hljs-comment">// Instantiation</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable">startingWeapon</span> = { <span class="hljs-variable">WeakDagger</span> }
<span class="hljs-keyword">var</span> <span class="hljs-variable">hero</span> = { <span class="hljs-variable">Character</span> <span class="hljs-string">&quot;Paul&quot;</span>, weapon: <span class="hljs-variable">startingWeapon</span> }

<span class="hljs-comment">// Scripts (any language, here shell)</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable">gameSaved</span> = <span class="language-shell">&lt;sh&gt;cat &quot;saved-gamed.json&quot;&lt;/sh&gt;</span>

<span class="hljs-comment">// Functions</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">announceGameIsStarted</span>
  <span class="hljs-built_in function_">#log</span> <span class="hljs-string">&#x27;Game started!&#x27;</span>
<span class="hljs-keyword">end</span>
<span class="hljs-title function_">announceGameIsStarted</span>()
</code></pre>
<h2>Disclaimer</h2>
<p>The language is very, very young and still contains a log of bugs. I don't recommend using yet for any real project.</p>
<p>I don't have a list of bugs yet, because there are too many.</p>
<h2>Installation</h2>
<pre><code class="language-sh"><span class="hljs-comment"># <span class="hljs-doctag">FIXME:</span> NPM PACKAGE IS NOT YET CREATED!</span>
npm install jome
</code></pre>
<h2>Usage</h2>
<pre><code class="language-sh"><span class="hljs-comment"># Usage</span>
jome <span class="hljs-comment"># executes index.jome in current or ancestor directory</span>
jome file.jome <span class="hljs-comment"># execute the given file</span>
jome server start <span class="hljs-comment"># pass the arguments &quot;server&quot; and &quot;start&quot; to index.jome executable</span>
</code></pre>
  <h2 id="lang-ref">Language Reference</h2>
<p>This documentation assumes the reader is familiar with javascript.</p>
<p>Jome is similar to JavaScript, but there are a few distinctions that you must be aware of. Mainly, the syntax is a bit different, there are nodes and scripts.</p>
  <h2 id="syntax">Syntax</h2>
<p>The syntax is similar to the ruby programming language. You use the keyword def instead of function.
And you use the end keyword instead of curly braces.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Person</span>
  <span class="hljs-keyword">def</span> <span class="hljs-variable">sayHello</span>
    <span class="hljs-built_in function_">#log</span> <span class="hljs-string">&#x27;Hello!&#x27;</span> <span class="hljs-comment">// #log is a util shorthand of console.log</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Parentheses are optional for function calls.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">add</span> = (<span class="hljs-variable">x</span>,<span class="hljs-variable">y</span>) =&gt; <span class="hljs-variable">x</span> + <span class="hljs-variable">y</span>
<span class="hljs-variable">add</span> <span class="hljs-number">10</span>, <span class="hljs-number">5</span>
</code></pre>
<p>You can pass arguments for a single object without using curly braces.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">add</span> = ({<span class="hljs-variable">x</span>, <span class="hljs-variable">y</span>}) =&gt; <span class="hljs-variable">x</span> + <span class="hljs-variable">y</span>
<span class="hljs-variable">add</span> x: <span class="hljs-number">10</span>, y: <span class="hljs-number">5</span>
</code></pre>
<p>To call a method on a object without parameters, you can use an arrow.</p>
<pre><code class="language-jome"><span class="hljs-variable">obj</span>-&gt;<span class="hljs-variable">density</span> <span class="hljs-comment">// same as obj.density()</span>
<span class="hljs-variable">obj</span>-&gt;<span class="hljs-variable">density</span> = <span class="hljs-number">1.05</span> <span class="hljs-comment">// def density=(val) // <span class="hljs-doctag">TODO:</span> WIP</span>
<span class="hljs-variable">obj</span>-&gt;<span class="hljs-variable">save</span>
</code></pre>
<p>You can use <code>do ... end</code> to create functions. You pass arguments between vertical bars.</p>
<pre><code class="language-jome">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-variable">each</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">i</span>|
  <span class="hljs-variable">console</span>.<span class="hljs-variable">log</span> <span class="hljs-variable">i</span>
<span class="hljs-keyword">end</span>
</code></pre>
  <h2 id="utils">Utils</h2>
<p>The language includes a lot of built-in functions and constants. They start with a hashtag (#) symbol.</p>
<p>For the complete list of utils: see the <a href="/jome/utils">utils page</a>.</p>
<pre><code class="language-jome"><span class="hljs-comment">// A constant</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in variable_">#PI</span>/<span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">e</span> = <span class="hljs-built_in function_">#e</span> <span class="hljs-comment">// Euler&#x27;s number</span>

<span class="hljs-comment">// A function</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">angle</span> = <span class="hljs-built_in function_">#sin</span>(<span class="hljs-variable">x</span>)
<span class="hljs-keyword">let</span> <span class="hljs-variable">logarithmic</span> = <span class="hljs-built_in function_">#log10</span>(<span class="hljs-number">2</span>)
<span class="hljs-built_in function_">#log</span>(<span class="hljs-string">&quot;The angle is:&quot;</span>, <span class="hljs-variable">angle</span>) <span class="hljs-comment">// #log is a shorthand for console.log</span>
</code></pre>
<p>By addind a dot before the hashtag, you can call the function with the preceding token as an argument.</p>
<pre><code class="language-jome"><span class="hljs-comment">// A function acting upon a variable</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">keys</span> = <span class="hljs-variable">obj</span>.<span class="hljs-built_in function_">#keys</span> <span class="hljs-comment">// same as #keys(obj) or Object.keys(obj)</span>
</code></pre>
<p>Utils include most things global in javascript and useful utils like in underscore.js.</p>
<p>Math: #PI, #sin, #cos, #tan, ..., #rand?
console: #log, ...
process: #argv, #env, #cwd...
underscore.js: #map, #reduce, ...</p>
<p>For functions that have a sync and async version, use the exclamation mark after to use the sync version.</p>
<pre><code class="language-jome"><span class="hljs-built_in function_">#write!</span> <span class="hljs-string">&#x27;./somefile.txt&#x27;</span>, <span class="hljs-string">&#x27;Some content&#x27;</span>, overwrite: <span class="hljs-literal">true</span>
</code></pre>
<h2>Types</h2>
<p>You can specify types for variables. It can be primitives like string, number, integer or float. It can also be class names or interfaces.</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(name: <span class="hljs-type">string</span>, greeting: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello&quot;</span>) : <span class="hljs-type">string</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`${greeting}, ${name}!`</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">attack</span>(enemy: <span class="hljs-variable">Player</span>)
  <span class="hljs-comment">/* ... */</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>You add a question mark after the type if the variable can be null.</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sayHello</span>(anybody: <span class="hljs-variable">Person</span>?): <span class="hljs-type">string</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`${greeting}, ${anybody.name}!`</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">anybody</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In a node block, you can specify the types of keys like so:</p>
<pre><code class="language-jome">{
  [key: <span class="hljs-type">string</span>]: <span class="hljs-variable">nb</span>; <span class="hljs-comment">// Here nb is a string</span>
};
</code></pre>
<p>But what about the types of children? (string)
{
MyNode
&quot;childString&quot;
(string) someFuncCallReturnsString
[string] someFuncCallReturnsString
someFuncCallReturnsString : string // Nooooooo, because it clashes with parameters...
}</p>
<p>You can create custom types. See interfaces and types. (TODO: link)</p>
  <h2 id="blocks">Blocks</h2>
<p>Blocks are delimited by curly braces and are used for a lot more than creating objects. You also use then to instantiate
objects, execute functions and to create <a href="#nodes">nodes</a></p>
<pre><code class="language-jome"><span class="hljs-comment">// objects</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">details</span> = {
  distanceX: <span class="hljs-number">30</span>, distanceY: <span class="hljs-number">40</span> <span class="hljs-comment">// comma is optional</span>
  totalDistance: <span class="hljs-number">50</span>, eta: <span class="hljs-number">10min</span>
}

<span class="hljs-comment">// values</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">obj</span> = {<span class="hljs-variable">Obj</span> prop: <span class="hljs-string">&#x27;val&#x27;</span>} <span class="hljs-comment">// instantiate an object</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">objRunResult</span> = {
  <span class="hljs-variable">Obj</span> prop: <span class="hljs-string">&#x27;val&#x27;</span>
    .<span class="hljs-variable">run</span> <span class="hljs-string">&#x27;some arg&#x27;</span>
}

<span class="hljs-comment">// nodes</span>
<span class="hljs-variable">node</span> = {
  <span class="hljs-variable">Obj</span> someProp: <span class="hljs-string">&#x27;obj&#x27;</span>
    <span class="hljs-string">&#x27;String child&#x27;</span>
    <span class="hljs-variable">Nested</span> prop: <span class="hljs-string">&#x27;val&#x27;</span>
}
</code></pre>
<p>Note: A value is only on a single line. Use parentheses if you need multiple lines.</p>
<pre><code class="language-jome">{
  x: <span class="hljs-number">1</span> +
     <span class="hljs-number">2</span> <span class="hljs-comment">// WRONG!</span>
  y: (<span class="hljs-number">1</span> +
     <span class="hljs-number">2</span>) <span class="hljs-comment">// OK</span>
}
</code></pre>
<h3>Shorthand key syntax</h3>
<p>The short key syntax is different that in javascript, because it could be confusing with children. In Jome, it starts with a colon</p>
<pre><code class="language-jome"><span class="hljs-variable">obj</span> = {:<span class="hljs-variable">content</span>, :<span class="hljs-variable">value</span>}
<span class="hljs-comment">// same as</span>
<span class="hljs-variable">obj</span> = {content: <span class="hljs-variable">content</span>, value: <span class="hljs-variable">value</span>}
</code></pre>
<h3>Work in progress V2</h3>
<p>We always know if the identifier is a function or a class. When it's local we know. We it's imported,
you add an ampersand before the identifier when it's a class.</p>
<p>import {func, &amp;klass} from 'lib'</p>
<p>I am not sure yet how I want to handle when you want to call new for a function and not a class, well I am not even sure I want to support this in Jome...</p>
<p>identifier // if identifier is a class, then new identifier(), otherwise identifier()
key: identifier // set identifier as a property of the instance
=identifier // add identifier as a children of the node
key = identifier // add identifier as a property of the object and as a children
:identifier // pass identifier to the constructor as a property of the object
.identifier // call function on parent</p>
<p>Le désavantage que je vois de faire key: identifier pour une propriété, est que c'est tanant pour le type.
Avec un = c'est facile rajouter le type. Mais d'un autre côté, est-ce qu'on veut vraiment mettre un type
là? Ça devrait être assez explicit en général. Et tu peux quand même le faire avec [key: type].</p>
<p>You can specify dynamic keys using square brackets. Ex: [<code>key_{name}</code>]</p>
<pre><code class="language-jome">{
<span class="hljs-variable">Recipe</span>
  name: <span class="hljs-string">&#x27;Chickpea balls&#x27;</span>
  prepare: <span class="hljs-number">1h</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">1cup</span>, <span class="hljs-string">&quot;dry chickpeas&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2cup</span>, <span class="hljs-string">&quot;water&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2tbsp</span>, <span class="hljs-string">&quot;parmesan&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">`Put {@1} into {@2}...`</span> <span class="hljs-comment">// @1 is the first children</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Mix ...&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Blah blah ...&quot;</span>
  .<span class="hljs-variable">prepare</span> <span class="hljs-string">&#x27;The recipe&#x27;</span>
  <span class="hljs-variable">Ing</span> ...
}
</code></pre>
<pre><code class="language-jome"><span class="hljs-comment">// Create a server, add a get handler and start it</span>
{
  <span class="hljs-variable">ExpressServer</span> port: <span class="hljs-number">3000</span>
    .<span class="hljs-variable">get</span> <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">req</span>, <span class="hljs-variable">res</span>|
      <span class="hljs-variable">res</span>.<span class="hljs-title function_">send</span>(<span class="hljs-variable">homePage</span>)
    <span class="hljs-keyword">end</span>
    .<span class="hljs-variable">start</span>
}
</code></pre>
<h3>Construction block</h3>
<p>You can apply a block onto an instance using #{ }.</p>
<pre><code class="language-jome"><span class="hljs-keyword">with</span>
  name: <span class="hljs-type">string</span>
  prepare: <span class="hljs-type">int</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Recipe</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare</span>(<span class="hljs-variable">str</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">class </span><span class="hljs-title class_">Ing</span>(qty: <span class="hljs-type">int</span> <span class="hljs-variable">along</span> <span class="hljs-variable">qtyFormat</span>, <span class="hljs-variable">@name</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">class </span><span class="hljs-title class_">Step</span>(<span class="hljs-variable">@instructions</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-variable">Recipe</span> #{
  name: <span class="hljs-string">&#x27;Chickpea balls&#x27;</span>
  prepare: <span class="hljs-number">1h</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">1cup</span>, <span class="hljs-string">&quot;dry chickpeas&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2cup</span>, <span class="hljs-string">&quot;water&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2tbsp</span>, <span class="hljs-string">&quot;parmesan&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">`Put {@1} into {@2}...`</span> <span class="hljs-comment">// @1 is the first children</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Mix ...&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Blah blah ...&quot;</span>
  .<span class="hljs-variable">prepare</span> <span class="hljs-string">&#x27;The recipe&#x27;</span>
  <span class="hljs-variable">Ing</span> ...
}
</code></pre>
<h3>Chain block</h3>
<p>You can create a chain block using chain ... end.</p>
<p>Chain returns the value of the last command.</p>
<pre><code class="language-jome"><span class="hljs-comment">// Create a server, add a get handler and start it</span>
<span class="hljs-variable">ExpressServer</span> port: <span class="hljs-number">3000 chain</span>
  <span class="hljs-variable">get</span> <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">req</span>, <span class="hljs-variable">res</span>|
    <span class="hljs-variable">res</span>.<span class="hljs-title function_">send</span>(<span class="hljs-variable">homePage</span>)
  <span class="hljs-keyword">end</span>
  <span class="hljs-variable">start</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-comment">// Create a server, add a get handler and start it</span>
{
  <span class="hljs-variable">ExpressServer</span> port: <span class="hljs-number">3000</span>
    someProp: <span class="hljs-string">&#x27;someVal&#x27;</span>
    <span class="hljs-keyword">chain</span>
      <span class="hljs-variable">get</span> <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">req</span>, <span class="hljs-variable">res</span>|
        <span class="hljs-variable">res</span>.<span class="hljs-title function_">send</span>(<span class="hljs-variable">homePage</span>)
      <span class="hljs-keyword">end</span>
      <span class="hljs-variable">start</span>
    <span class="hljs-keyword">end</span>
}
</code></pre>
<pre><code class="language-jome"><span class="hljs-keyword">import</span> <span class="hljs-variable">express</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>

<span class="hljs-keyword">let</span> <span class="hljs-variable">port</span> = <span class="hljs-number">3000</span>

<span class="hljs-variable">express</span> <span class="hljs-keyword">chain</span>
  <span class="hljs-variable">get</span> <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">req</span>, <span class="hljs-variable">res</span>|
    <span class="hljs-variable">res</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>)
  <span class="hljs-keyword">end</span>
  <span class="hljs-variable">listen</span> <span class="hljs-variable">port</span> <span class="hljs-keyword">do</span>
    <span class="hljs-built_in function_">#log</span> <span class="hljs-string">`Server listening on port {port}`</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Compiles to</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>

<span class="hljs-keyword">let</span> port = <span class="hljs-number">3000</span>

(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> __chain = <span class="hljs-title function_">express</span>()
  __chain.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>)
  })
  <span class="hljs-keyword">return</span> __chain.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server listening on port {port}`</span>)
  })
})()
</code></pre>
<h3>Lists inside blocks</h3>
<p>A block { } will return only one object. Use {[ ]} to generate a list of objects.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">listObjs</span> = {[
  <span class="hljs-variable">Obj</span> name: <span class="hljs-string">&#x27;foo&#x27;</span>
  <span class="hljs-variable">Obj</span> name: <span class="hljs-string">&#x27;bar&#x27;</span>
]}
</code></pre>
<h3>At (@)</h3>
<p>One of the objective of Jome is to remove the weird thing that is this.</p>
<p>I want in Jome this to refer to the current instance when inside a method and that's it.</p>
<p>In order to do this, I should bind automatically all the functions inside the class to the proper this.
Inside the constructor:
everyMethod1.bind(this)
everyMethod2.bind(this)
Then inside the everyMethod1:
__this = this
everyMethod2:
__this = this</p>
<p>At is usually the same as the keyword this.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">_this</span> = @ <span class="hljs-comment">// same as this</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-variable">@name</span> <span class="hljs-comment">// same as this.name</span>
</code></pre>
<p>Idea: But it can also be used to refer to children.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">firstChild</span> = <span class="hljs-variable">@1</span> <span class="hljs-comment">// Child index starts at 1</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">secondChild</span> = <span class="hljs-variable">@2</span>
</code></pre>
<p>TODO: Use the keyword self instead of this, this makes it clear that it refers to self inside a class,
and that it is a little different than this in javascript in that it always refer to the class instance.</p>
<p>Use #evt to get current event
Use window or #window to get the window</p>
<h3>Exclamation mark in objects</h3>
<p>Inside an object, you can use an exclamation mark after a variable name so it sets it value to true.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">obj</span> = {<span class="hljs-variable">someCond</span>!} <span class="hljs-comment">// same as {someCond: true}</span>
</code></pre>
<h2>Paths</h2>
<p>The issue with relative paths is that you don't know what they are relative to. In js, in include files,
the relative path is relative to the current file. If you try to open and write a file, than it is relative
to the current working directory.</p>
<p>In Jome, this is more explicit using paths. '#./' is used for paths relative to current file, '#cwd/' is used for
paths relative to the current working directory. They are compiled to become absolute, so you can pass it to
a function in another file and you are sure it will reference the proper file.</p>
<p>You can use # to define paths. They must start by '/', '.' or 'cwd/'. (Maybe '~' too)</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">path0</span> = #. <span class="hljs-comment">// same as __dirname</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">path1</span> = #/<span class="hljs-variable">some</span>/<span class="hljs-variable">absolute</span>/<span class="hljs-variable">path</span>.<span class="hljs-variable">txt</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">path2</span> = #./<span class="hljs-variable">someFile</span>.<span class="hljs-variable">jome</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">path3</span> = #../<span class="hljs-variable">otherDir</span>/<span class="hljs-string">&quot;some file with spaces.txt&quot;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">path4</span> = <span class="hljs-built_in variable_">#cwd</span>/<span class="hljs-variable">someFile</span>.<span class="hljs-variable">txt</span> <span class="hljs-comment">// Allow paths after #cwd to get files inside current working directory.</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">path5</span> = #~/<span class="hljs-variable">Downloads</span>/<span class="hljs-variable">someFile</span>.<span class="hljs-variable">txt</span> <span class="hljs-comment">// Maybe</span>
</code></pre>
<p>Relative paths are converted to absolute paths. It's the same as joining __dirname with the relative path.</p>
<p>Spaces are not allowed, but you can escape them. Any other character is allowed?</p>
<p>You can use quotes inside paths, just not at the beginning. You can use like like so:</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">test</span> = #./<span class="hljs-string">&#x27;some/file with spaces.txt&#x27;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">test</span> = #/<span class="hljs-string">&#x27;some/file with spaces.txt&#x27;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">test</span> = #./<span class="hljs-string">&quot;some/file with spaces.txt&quot;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">test</span> = #/<span class="hljs-string">&quot;some path/file with spaces.txt&quot;</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">test</span> = #/<span class="hljs-variable">some</span>/<span class="hljs-variable">path</span>/<span class="hljs-variable">to</span>/<span class="hljs-variable">some</span>/<span class="hljs-string">&quot;file with spaces.txt&quot;</span>
</code></pre>
<p>If you want quotes inside your filename, than you need to escape them.</p>
<p>No interpolation inside jome paths?</p>
<p>Paths always use the /, but maybe they are converted when compiling for Windows?</p>
<p>Si je me retrouve à tout le temps faire #run(#./some_file.ext), ça serait nice d'avoir un
shortcut.</p>
<p>Par exemple, r#./some_file.html.jome</p>
<p>Ce que j'aime du r ici c'est que ça veut dire run et ça veut dire read aussi.</p>
<p>En fait c'est peut-être run! que j'utilise plus souvent.</p>
<p>Utiliser !#./some_file.html.jome // Comme shortcut?</p>
<h2>Executing jome files</h2>
<p>.jome files are compiled into a function. When you use jome CLI to run a .jome file, you are executing this
function and passing args to the function.</p>
<p>You can use return inside a .jome file to exit prematurly or to return a value.</p>
<p>You can use #run or #load to run another .jome file within jome.</p>
<pre><code class="language-jome"><span class="hljs-built_in function_">#run</span> <span class="hljs-string">&#x27;./some_file.jome&#x27;</span>
<span class="hljs-comment">// compiles to:</span>
<span class="hljs-comment">// import run_some_file from &#x27;some_file.jome&#x27;</span>
<span class="hljs-comment">// run_some_file()</span>
</code></pre>
<p>Jome files can be included into other jome files. This allows you to easily create partials and file improved with Jome.</p>
<p>C'est utile pour générer des fichiers d'autres types aussi.</p>
<p>data.json.jome</p>
<pre><code class="language-jome"><span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;<span class="hljs-name">json</span>&gt;</span>
  {
    <span class="hljs-string">&quot;some&quot;</span>: <span class="hljs-string">&quot;data&quot;</span>,
    <span class="hljs-string">&quot;title&quot;</span>: &lt;% <span class="hljs-variable">title</span> %&gt;,
    <span class="hljs-string">&quot;math&quot;</span>: &lt;% <span class="hljs-number">1</span> + <span class="hljs-number">2</span> %&gt;
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">json</span>&gt;</span>
</code></pre>
<p>some_file.jome</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> data: <span class="hljs-type">string</span> = <span class="hljs-built_in function_">#run</span> <span class="hljs-string">&#x27;./data.json.jome&#x27;</span>, title: <span class="hljs-string">&#x27;Some title!&#x27;</span>
</code></pre>
<p>Je ne sais pas encore pour des fichiers jome avec des modules et des exports. Peut-être un type de fichier différent? .jomm?</p>
<p>some_page.html.jome, dans ce cas un fichier some_page.html.js est généré, il n'est pas exécuter automatiquement.</p>
<p>Tu peux faire:</p>
<p>#write #run(#./some_page.html.jome), to: #./some_page.html
ou peut-être fournir un shortcut genre
#compile #./some_page.html.jome</p>
<p>Compiler tous les fichiers .jome avec un default export de function pour le script. Parce que présentement, ce n'est
pas simple d'appeler plusieurs fois le même fichier. Ce qui est un peu tanant c'est qu'il faut que je fasse
node -e &quot;require('some_compiled_file.js')()&quot; au lieu de juste node some_compiled_file.js</p>
<p>You specify the variables you expect to be given to the partial file with a with block.</p>
<pre><code class="language-jome"><span class="hljs-keyword">with</span>
  {title: <span class="hljs-type">string</span>}
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;% title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
</code></pre>
<p>A Jome script is compiled into a function with the parameters described from the with block.</p>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">{title}</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>#run et #load qui font tous les deux la même chose?
et
#run! et #load!</p>
<p>Comment gérer le fichier dynamiquement?</p>
<p>#load('file.jome')
#load(nameOfFile)</p>
<p>Ça ne change rien en fait, c'est juste que ça va être dynamique ou pas. Dans tous les cas je vais faire require sur place
ou await import sur place.</p>
<p>FIXMEEEE run avec ESM doit utiliser await import, mais je ne veux pas toujours retourner une valeur async...</p>
<p>Mais mon trouble là c'est avec les dynamic imports. Mettre ça de côté pour l'instant</p>
<h2>Loops</h2>
<p>Loops are used exactly like in javascript, but with the end keyword.</p>
<p>Nooooooooooo. They are disguting. There is for...in, for...of, it's ugly. I don't even know
how to use them properly... Check other languages to find a better way.</p>
<p>Note: There is no do ... while, because the do keyword is used for functions.
Maybe exec ... while ???</p>
<pre><code class="language-jome"><span class="hljs-title function_">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">el</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">els</span>)
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title function_">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-variable">list</span>.<span class="hljs-variable">length</span>; <span class="hljs-variable">i</span>++)
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title function_">while</span> (<span class="hljs-variable">someCondition</span>)
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
  <h2 id="nodes">Nodes</h2>
<p>Nodes are objects in a tree structure. They can have a parent and they can have children.</p>
<p>You create nodes by using blocks.</p>
<pre><code class="language-jome"><span class="hljs-variable">node</span> = {
  <span class="hljs-variable">Obj</span> prop1: <span class="hljs-string">&#x27;val&#x27;</span>, prop2: <span class="hljs-string">&#x27;val2&#x27;</span>
    prop3: <span class="hljs-string">&#x27;val3&#x27;</span>, prop4: <span class="hljs-string">&#x27;val4&#x27;</span>
    <span class="hljs-variable">propAndChild1</span> = <span class="hljs-string">&#x27;val5&#x27;</span>
    <span class="hljs-variable">propAndChild2</span> = <span class="hljs-string">&#x27;val6&#x27;</span>
}
</code></pre>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Node</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">constructor</span>(props: <span class="hljs-variable">Object</span>)
    <span class="hljs-title function_">set</span>(<span class="hljs-variable">props</span>)
    <span class="hljs-variable">this</span>.<span class="hljs-variable">props</span> = <span class="hljs-variable">props</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(attrs: <span class="hljs-variable">Object</span>)
    <span class="hljs-comment">// Assign each entry of the object to &#x27;this&#x27;</span>
    <span class="hljs-title function_">for</span> (<span class="hljs-variable">const</span> <span class="hljs-variable">key</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">props</span>)
      <span class="hljs-title function_">if</span> (<span class="hljs-variable">props</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-variable">key</span>)) {
        <span class="hljs-variable">this</span>[<span class="hljs-variable">key</span>] = <span class="hljs-variable">props</span>[<span class="hljs-variable">key</span>];
      }
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Adding children to nodes</h3>
<p>In order to add children to nodes, you can use the &lt;&lt; operator.</p>
<pre><code class="language-jome"><span class="hljs-variable">hero</span>.<span class="hljs-variable">inventory</span> &lt;&lt; {[
  <span class="hljs-variable">Sword</span> damage: <span class="hljs-number">10</span>, weight: <span class="hljs-number">500g</span>
  <span class="hljs-variable">Shield</span> armor: <span class="hljs-number">8</span>, weight: <span class="hljs-number">400g</span>
  <span class="hljs-variable">Scroll</span> <span class="hljs-string">&quot;Scroll of wisdom&quot;</span>
  <span class="hljs-variable">Belt</span>
    <span class="hljs-variable">HealingPotion</span> life: <span class="hljs-number">200</span>
    <span class="hljs-variable">ManaPotion</span> mana: <span class="hljs-number">100</span>
]}
</code></pre>
<h3>Children attached with key</h3>
<p>LES NODES N'ONT PAS DE NOM, MAIS TU PEUX LES ATTACHER AVEC UNE CLÉ À UN PARENT
QUAND TU ATTACHES UN CHILDREN AVEC UNE CLÉ, il est là ET il est dans la liste de children.
si tu veux mettre à un attribute, mais pas children, alors utiliser @attr</p>
<pre><code class="language-jome">$ &lt;&lt;
  someVar: <span class="hljs-number">10</span>
  page: <span class="hljs-variable">Page</span>
    navbar: <span class="hljs-variable">Navbar</span>
      list: <span class="hljs-variable">List</span>
        <span class="hljs-variable">Link</span> <span class="hljs-string">&quot;Musics&quot;</span>, to: <span class="hljs-string">&#x27;/musics&#x27;</span>
        <span class="hljs-variable">Link</span> <span class="hljs-string">&quot;Sports&quot;</span>, to: <span class="hljs-string">&#x27;/sports&#x27;</span>
        <span class="hljs-variable">Link</span> <span class="hljs-string">&quot;Arts&quot;</span>, to: <span class="hljs-string">&#x27;/arts&#x27;</span>
    <span class="hljs-variable">Body</span>
      <span class="hljs-variable">Txt</span> &lt; <span class="hljs-variable">md</span> &gt;
        <span class="hljs-comment"># Welcome</span>
        <span class="hljs-variable">Welcome</span> <span class="hljs-variable">to</span> <span class="hljs-variable">this</span> <span class="hljs-variable">website</span>! <span class="hljs-variable">You</span> <span class="hljs-variable">can</span> <span class="hljs-variable">browse</span> <span class="hljs-variable">links</span> <span class="hljs-variable">at</span> <span class="hljs-variable">the</span> <span class="hljs-variable">top</span>.
      &lt; / <span class="hljs-variable">md</span>&gt;
&gt;&gt;
<span class="hljs-keyword">var</span> <span class="hljs-variable">navLinks</span> = $<span class="hljs-variable">page</span>.<span class="hljs-variable">navbar</span>.<span class="hljs-variable">list</span>-&gt;<span class="hljs-variable">children</span>
</code></pre>
<h3>Under the hood</h3>
<p>Underneath, nodes are objects with a property named '$'. The idea of doing it this way is in order to not clash with user defined properties for
example name.</p>
<p>The property includes the following attributes:</p>
<ul>
<li>children: The list of children of the node.</li>
<li>parent: A link to the node who is it's parent</li>
<li>signals: A list of the signals the node listens to</li>
<li>childrenCount: The number of children of the node. Not sure about this one. TODO: Remove this since I can do children.length</li>
</ul>
<h2>Conditions</h2>
<pre><code class="language-jome"><span class="hljs-keyword">if</span> <span class="hljs-variable">someCond</span>
  <span class="hljs-variable">doSomething</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> <span class="hljs-variable">someCond</span>
  <span class="hljs-variable">doSomething</span>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">someOtherCond</span>
  <span class="hljs-variable">doSomething</span> <span class="hljs-comment">// all valid</span>
<span class="hljs-keyword">elsif</span> <span class="hljs-variable">someOtherCond</span>
  <span class="hljs-variable">doSomething</span> <span class="hljs-comment">// all valid</span>
<span class="hljs-keyword">elif</span> <span class="hljs-variable">someOtherCond</span>
  <span class="hljs-variable">doSomething</span> <span class="hljs-comment">// all valid</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-variable">doSomething</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>return &quot;some val&quot; if someCond</p>
<p>An if modifier executes everything to it's left only if the condition is true</p>
<p>An if does not return anything, except in a block. So you can use a block to assing a value conditionally.</p>
<pre><code class="language-jome"><span class="hljs-variable">someVar</span> = {
  <span class="hljs-keyword">if</span> <span class="hljs-variable">someCond</span>
    <span class="hljs-string">&quot;someVal&quot;</span>
  <span class="hljs-keyword">elsif</span> <span class="hljs-variable">someOtherCond</span>
    <span class="hljs-string">&quot;some other val&quot;</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-string">&quot;some default&quot;</span>
  <span class="hljs-keyword">end</span>
}
</code></pre>
<p>Le keyword then peut être utiliser pour mettre la valeur sur la même ligne que la condition</p>
<pre><code class="language-jome"><span class="hljs-variable">someVar</span> = {
  <span class="hljs-keyword">if</span> <span class="hljs-variable">someCond</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;someVal&quot;</span>
  <span class="hljs-keyword">elsif</span> <span class="hljs-variable">someOtherCond</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;some other val&quot;</span>
  <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;some default&quot;</span> <span class="hljs-keyword">end</span>
}
</code></pre>
<p>You can use elif, elsif or else if, they are all the same.</p>
<p>Comment est-ce que ça comporterait un if modifier dans un node block?
Ça marche pour ajouter des childrens conditionnellement.</p>
<pre><code class="language-jome"><span class="hljs-variable">someVar</span> = {[
  <span class="hljs-string">&quot;item1&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">someCond</span>
  <span class="hljs-string">&quot;item2&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-variable">someOtherCond</span>
  <span class="hljs-string">&quot;item3 always there&quot;</span>
]}
</code></pre>
<p>J'aimerais pouvoir utiliser un if modifier dans un string literal.</p>
<p>someStr = <code>Hello{' '+name if name}</code></p>
<p>Et j'aimerais que dans ce cas, ça retourne automatiquement '' au lieu de undefined ou null</p>
<h2>comments</h2>
<p>Use // and /* */ for regular comments.</p>
<p>Use # for documentation comments. NOTE: It must have a space after the # , otherwise it's a utils.</p>
<pre><code class="language-jome"><span class="hljs-comment">// This is a regular comment</span>

<span class="hljs-keyword">let</span> <span class="hljs-variable">foo</span> = <span class="hljs-number">10</span> <span class="hljs-comment"># comment after?</span>

 <span class="hljs-comment"># This is a documentation comment that describes the function below.</span>
 <span class="hljs-comment"># Second line of same documentation comment.</span>
<span class="hljs-keyword">with</span>
  arg: <span class="hljs-type">string</span> <span class="hljs-comment"># Documentation comment that describes what this argument is</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span>
  <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> implement this function */</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>By default, regular comments are discarded when compiled and documentation comments are kept.</p>
<h3>Switch / case</h3>
<p>Mon idée, tu fais:
case someVal
Ça assigne la valeur someVal comme valeur temporaire qui va être utilisée.
Ensuite, quand tu call when, ça compare avec la valeur de someVal</p>
<p>ex:
let cmd = &quot;yell&quot;
case cmd
// Any code can be here it does not matter
return &quot;HELLO WORLD&quot; when &quot;yell&quot;
let someVar = &quot;hello&quot; when &quot;talk&quot; else
&quot;hola&quot; when &quot;spanish&quot; else
&quot;sup&quot;</p>
<p>Par défault, when fais simplement une comparaison.
Mais tu peux utiliser d'autre opérations avec en suivant when d'un opérateur</p>
<p>case number
return &quot;very big number&quot; when &gt; 10000
return &quot;big number&quot; when &gt; 1000
return &quot;number&quot;</p>
<p>Le case doit être dans le scope des when. Tu ne peux pas par exemple le mettre caché dans le if.
Les when sont simplement remplacé par &quot;if (expression du case)&quot;</p>
<h2>Classes</h2>
<p>Normal arguments are only available inside the constructor.
The constructor is everything inside the class before the first def ... end.
If you use @someArgument, then it will automatically set it for you.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Person</span>(<span class="hljs-variable">favoriteColor</span>)
  <span class="hljs-variable">@firstName</span>: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;John&quot;</span>
  <span class="hljs-variable">@lastName</span>: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Doe&quot;</span>
  <span class="hljs-variable">@age</span>: <span class="hljs-variable">number</span>
  <span class="hljs-variable">@favoriteColor</span> = <span class="hljs-variable">favoriteColor</span> || <span class="hljs-string">&#x27;brown&#x27;</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">with</span>
  <span class="hljs-variable">@favoriteColor</span> = <span class="hljs-string">&#x27;brown&#x27;</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Person</span>
  <span class="hljs-variable">@firstName</span>: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;John&quot;</span>
  <span class="hljs-variable">@lastName</span>: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Doe&quot;</span>
  <span class="hljs-variable">@age</span>: <span class="hljs-variable">number</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">class </span><span class="hljs-title class_">Person</span>
  <span class="hljs-variable">@username</span>: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Bigdaddy007&quot;</span> <span class="hljs-comment">// same as doing @username = &quot;Bigdaddy007&quot; inside the constructor</span>
  <span class="hljs-variable">@username</span>?: <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Bigdaddy007&quot;</span> <span class="hljs-comment">// same as doing @username = #params.username || &quot;Bigdaddy007&quot; inside the constructor</span>
  <span class="hljs-variable">@usersame</span> <span class="hljs-comment">// does nothing</span>
  <span class="hljs-variable">@username</span> <span class="hljs-comment">// same as doing @username = null inside the constructor</span>
  
  @<span class="hljs-variable">@className</span> = <span class="hljs-string">&quot;Person&quot;</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>All attributes are public because it is javascript, so no need for attr_reader, attr_accessor...</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">SomeClass</span>

  <span class="hljs-variable">super</span> <span class="hljs-variable">AbstractClass</span>

  <span class="hljs-variable">attr</span> <span class="hljs-variable">someAttr</span> = <span class="hljs-string">&quot;defaultValue&quot;</span>

  <span class="hljs-variable">children</span> {[
    <span class="hljs-variable">DefaultChild</span> <span class="hljs-string">&quot;blah&quot;</span>
    <span class="hljs-variable">DefaultChild</span> <span class="hljs-string">&quot;blah&quot;</span>
  ]}
    
  <span class="hljs-keyword">def</span> <span class="hljs-variable">someMethod</span> |<span class="hljs-variable">someArg</span>|

  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<h3>Methods</h3>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">SomeClass</span>
  <span class="hljs-comment">// Multiple lines methods</span>
  <span class="hljs-keyword">def</span> <span class="hljs-variable">someMethod</span>
    <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// Inline methods</span>
  <span class="hljs-variable">add10</span> = <span class="hljs-variable">x</span> =&gt; <span class="hljs-variable">x</span> + <span class="hljs-number">10</span>

  <span class="hljs-comment">// Alias</span>
  <span class="hljs-variable">addTen</span> = <span class="hljs-variable">add10</span>

  <span class="hljs-comment">// What about constants? Is this allowed?</span>
  <span class="hljs-variable">constant</span> = <span class="hljs-number">125</span> <span class="hljs-comment">// What does this meannnnnnn??</span>
  @<span class="hljs-variable">@constant</span> = <span class="hljs-number">125</span> <span class="hljs-comment">// Double ampersand! What does this meannnnnnn?!?!</span>

  <span class="hljs-variable">@token</span> = ... <span class="hljs-comment">// attached to instance (set in constructor)</span>
  <span class="hljs-variable">token</span> = ... <span class="hljs-comment">// attached to prototype</span>
  @<span class="hljs-variable">@token</span> = ... <span class="hljs-comment">// static, attached to class</span>

  <span class="hljs-comment">// SomeClass.constant</span>

  <span class="hljs-keyword">def</span> @<span class="hljs-variable">@staticMethod</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Idée: Quand une classe inhérite d'un interface, mettre les valeurs par défaut dans le prototype.</p>
<h3>Inline methods</h3>
<p>Pouvoir définir une méthode sur une seule ligne avec def &lt; funcName &gt; =</p>
<pre><code>class SomeClass
  def inlineMethod = &quot;someText&quot; // Careful here it is a function, not only a string
  // same as
  def inlineMethod
    return &quot;someText&quot;
  end

  def inlineMethod2 = {
    key: 'value'
  }
  // same as
  def inlineMethod2
    return {
      key: 'value'
    }
  end
end
</code></pre>
<h3>Deconstructings</h3>
<p>I want to be able to name deconstructed arguments in a method. Maybe with keyword as?</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-variable">props</span> <span class="hljs-variable">as</span> {<span class="hljs-variable">arg1</span>, <span class="hljs-variable">arg2</span>})
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Class arguments</h3>
<p>Class arguments are read-only. They are available from everywhere inside the class, every method not just constructor.</p>
<p>If you want the value to be set for the instance, use an ampersand before the variable name.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Tag</span>(<span class="hljs-variable">@name</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name
  }
}
</code></pre>
<p>If you want to add everything from an object, what to do then? Keyword include?</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Tag</span>(<span class="hljs-variable">props</span>)
  <span class="hljs-variable">include</span> <span class="hljs-variable">props</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Tag</span>(<span class="hljs-variable">tag</span>, <span class="hljs-variable">content</span>)
  <span class="hljs-keyword">def</span> <span class="hljs-variable">toString</span> = =&gt; <span class="hljs-string">`&lt;{tag}{renderHTMLAttrs(@)}&gt;{content||&#x27;&#x27;}{renderHTMLChildren(@)}&lt;/{tag}&gt;`</span>
  <span class="hljs-keyword">def</span> <span class="hljs-variable">createElem</span> = =&gt; <span class="hljs-title function_">createElem</span>(@, <span class="hljs-variable">tag</span>, <span class="hljs-variable">content</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> <span class="hljs-variable">TagProps</span>
  foo: <span class="hljs-variable">bar</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">class </span><span class="hljs-title class_">Tag</span>(props: <span class="hljs-variable">TagProps</span>) &lt; <span class="hljs-title function_">Node</span>(<span class="hljs-variable">props</span>)

<span class="hljs-keyword">end</span>
</code></pre>
<p>Qu'est-ce que ça implique de faire ça?</p>
<p>Qu'est-ce que ça peut vouloir dire:</p>
<ul>
<li>je veux que le premier argument du constructeur soit tag, et setter this.tag = tag</li>
<li>je veux avoir accès à tag sans nécessairement le rendre public, encapsulter par une fonction?</li>
<li>je veux pouvoir faire tag: tag dans le constructeur.</li>
</ul>
<p>No constructor. Constructor code directly inside class.</p>
<h3>Inheritence</h3>
<p>WIP</p>
<h3>Constructor</h3>
<p>No constructor? If you want to call a method like a constructor, then call it.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">SomeClass</span>(<span class="hljs-variable">options</span>)
  <span class="hljs-variable">@init</span>()

  <span class="hljs-keyword">def</span> <span class="hljs-variable">init</span>
    
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Inject object</h3>
<p>I want to be able to inject an object into an instance. But what syntax to use???</p>
<p>Keyword include?</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">ExpressServer</span>(<span class="hljs-variable">options</span>)

  <span class="hljs-variable">include</span> <span class="hljs-variable">options</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2>Modules and exports</h2>
<p>There are many ways to export items, but they are all compiled the same. Either using module.exports or export depending on jome config.</p>
<pre><code class="language-jome"><span class="hljs-keyword">module</span>
  <span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">someVar</span> = <span class="hljs-number">10</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Compiles to</p>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">someFunc</span>: <span class="hljs-function">() =&gt;</span> {
  },
  <span class="hljs-attr">someVar</span>: <span class="hljs-number">10</span>
}
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someFunc</span>(<span class="hljs-params"></span>) {
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> someVar = <span class="hljs-number">10</span>
</code></pre>
<p>You can give a name to the module, which simply creates an object that holds everything inside.</p>
<pre><code class="language-jome"><span class="hljs-keyword">module</span> <span class="hljs-variable">SomeModule</span>
  <span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">someVar</span> = <span class="hljs-number">10</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// usage:</span>
<span class="hljs-comment">// import {SomeModule} from &#x27;./some_file.jome&#x27;</span>
<span class="hljs-comment">// let ten = SomeModule.someVar</span>
</code></pre>
<p>You can also export functions and constants individually.</p>
<pre><code class="language-jome"><span class="hljs-keyword">export</span> <span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">someVar</span> = <span class="hljs-number">10</span>

<span class="hljs-comment">// usage:</span>
<span class="hljs-comment">// import {someFunc, someVar} from &#x27;./some_file.jome&#x27;</span>
</code></pre>
<p>To export the default or an object, use the main keyword. It allows you to return a value from a file.</p>
<pre><code class="language-jome"><span class="hljs-comment">// sum.jome</span>
<span class="hljs-keyword">main</span> |<span class="hljs-variable">a</span>, <span class="hljs-variable">b</span>| =&gt; (<span class="hljs-variable">a</span> + <span class="hljs-variable">b</span>)

<span class="hljs-comment">// usage:</span>
<span class="hljs-comment">// import sum from &#x27;./sum.jome&#x27;</span>
</code></pre>
<h2>Interfaces and types</h2>
<p>I find interfaces and types to be confusing in Typescript as someone who does know to language. In order to avoid
the confusion, you cannot declare an object with type. So you use interface for an object, and type otherwise.</p>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> <span class="hljs-variable">Dimensions</span>
  width: <span class="hljs-variable">number</span>
  height: <span class="hljs-variable">number</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// Alias</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable">Dim</span> = <span class="hljs-variable">Dimensions</span>

<span class="hljs-comment">// Unions</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable">DimOrStr</span> = <span class="hljs-variable">Dim</span> | <span class="hljs-type">string</span>

<span class="hljs-comment">// Tuples</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable">DimAndStr</span> = [<span class="hljs-variable">Dim</span>, <span class="hljs-type">string</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">funcWithDimensions</span>(<span class="hljs-variable">dim</span> : <span class="hljs-variable">Dim</span>)
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Inheritence</h3>
<p>You can use &lt; for extending an interface.</p>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> <span class="hljs-variable">Dim3d</span> &lt; <span class="hljs-variable">Dimensions</span>
 depth: <span class="hljs-variable">number</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> <span class="hljs-variable">Weapon</span> <span class="hljs-variable">damage</span>, <span class="hljs-variable">range</span> <span class="hljs-keyword">end</span>

<span class="hljs-comment">// When you inherit from an interface, you can call super on the interface to initialize some values</span>

<span class="hljs-comment">// Inheritence and properties</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Dagger</span> &lt; <span class="hljs-title function_">Weapon</span>(range: <span class="hljs-number">50</span>) <span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">WeakDagger</span> &lt; <span class="hljs-title function_">Dagger</span>(damage: <span class="hljs-number">50</span>) <span class="hljs-keyword">end</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">StrongDagger</span> &lt; <span class="hljs-title function_">Dagger</span>(damage: <span class="hljs-number">200</span>) <span class="hljs-keyword">end</span>
</code></pre>
<h3>Intersection</h3>
<p>You can use intersection to create a type that combines the properties of two interfaces together.</p>
<h3>Function types</h3>
<p>You can give a single function signature to a type. You can give function signatures to variables in interfaces.</p>
<pre><code class="language-jome"><span class="hljs-keyword">type</span> <span class="hljs-variable">log</span> = (val: <span class="hljs-type">string</span>) =&gt; <span class="hljs-variable">void</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-variable">WithLog</span>
  log: (val: <span class="hljs-type">string</span>) =&gt; <span class="hljs-variable">void</span>;
<span class="hljs-keyword">end</span>
</code></pre>
<p>For function overloading, you can use unions.</p>
<pre><code class="language-jome"><span class="hljs-keyword">type</span> <span class="hljs-variable">log</span> = (val: <span class="hljs-type">string</span>) =&gt; <span class="hljs-variable">void</span> | (val: <span class="hljs-variable">number</span>) =&gt; <span class="hljs-variable">void</span>;
</code></pre>
<h3>Default values</h3>
<p>Contrary to Typescript, you can add default values in an interface.</p>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> <span class="hljs-variable">Options</span>
  method: <span class="hljs-type">string</span> = <span class="hljs-string">&#x27;get&#x27;</span>
  ttl: <span class="hljs-variable">number</span> = <span class="hljs-number">30s</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Declaration Merging</h3>
<p>By default, you cannot redeclare an interface and it adds to the previous one.</p>
<p>You have to use another syntax to do this. Maybe interface &lt;</p>
<pre><code class="language-jome"><span class="hljs-keyword">interface</span> &lt; <span class="hljs-variable">Options</span>
  arg: <span class="hljs-type">string</span> = <span class="hljs-string">&#x27;one more option&#x27;</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Class extends interface</h3>
<p>A class can extend an interface.</p>
<p>Interface default values will given given to the instance by default in the constructor.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">SomeClass</span>(<span class="hljs-variable">props</span>) &lt; <span class="hljs-title function_">SomeInterface</span>(<span class="hljs-variable">props</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<h3>Source for decisions</h3>
<p>https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript</p>
<h3>Functions</h3>
<pre><code class="language-jome"><span class="hljs-comment">// Utilise la syntaxe comme ruby</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">sayHello</span>
  <span class="hljs-built_in function_">#log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">def</span> <span class="hljs-variable">sayHelloTo</span> <span class="hljs-keyword">do</span> |<span class="hljs-variable">name</span>|
  <span class="hljs-built_in function_">#log</span>(<span class="hljs-string">`Hello! {name}`</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Je ne veux pas que le user n'aie à faire la distinction entre une fonction et une arrow fonction.
Trouver une manière de gérer cela.</p>
<h3>With keyword</h3>
<p>Usefull to define interfaces of classes and functions.</p>
<pre><code class="language-jome"><span class="hljs-keyword">with</span>
  name: <span class="hljs-type">String</span> <span class="hljs-comment"># Full name of the personnellement</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Person</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">with</span>
  x: <span class="hljs-type">float</span> <span class="hljs-comment"># The base value</span>
  y: <span class="hljs-variable">integer</span> <span class="hljs-comment"># The factor</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">multiply</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This allows easy documentation of the code without having to repeat yourself in the comments.</p>
<p>It would be nice is there was a short way to start a single line documentation comment.</p>
<h2>State variables</h2>
<p>Nodes can have state variables that start with a percentage sign like <code>%stateVar = 10</code></p>
<pre><code class="language-jome">{ <span class="hljs-comment">// %count does not have to be declared in the Btn class, you can attach any state to any node</span>
  <span class="hljs-variable">Btn</span> %count: <span class="hljs-number">0</span>, ~click: =&gt; (%<span class="hljs-variable">count</span> += <span class="hljs-number">1</span>)
    <span class="hljs-variable">Txt</span> <span class="hljs-string">&quot;Clicked {%count} {%count == 1 ? &#x27;time&#x27; : &#x27;times&#x27;}&quot;</span>  
}
<span class="hljs-comment">// Txt does not have a %count state variable, so it checks to see if it&#x27;s parent has one. Yes, Btn has a state variable called %count.</span>
<span class="hljs-comment">// So Txt will add itself as a dependency on Btn state. It Btn state changes, then Txt will be updated too.</span>
</code></pre>
<p>C'est OK, mais j'aimerais pouvoir dire à qui appartient le state au lieu d'être à l'aveugle comme ça.</p>
<p>J'aimerais pouvoir setter le state à travers un nom de node? Je ne sais pas ce n'est pas si explicit non plus...</p>
<p>Qu'est-ce qui se passe si le node et ses parents n'ont pas le state?</p>
<p>State variables inside classes.</p>
<p>Class using parent state:</p>
<pre><code class="language-jome"><span class="hljs-comment">// A question mark when dependent on a state or an exclamation mark (silent vs throw exception?)</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">ColoredText</span> |<span class="hljs-variable">@text</span>, %<span class="hljs-variable">theme</span>?| {
  print: () =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;p style=&quot;color: {%theme.textColor}&quot;&gt;{%theme}&lt;/p&gt;`</span>
  }
}
</code></pre>
<p>Class having state:</p>
<pre><code class="language-jome"><span class="hljs-comment">// No question mark having state</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">App</span> |%<span class="hljs-variable">theme</span>| {
  init: () =&gt; {
    %<span class="hljs-variable">theme</span> = {
      textColor: <span class="hljs-string">&quot;red&quot;</span>
    }
  }
}
</code></pre>
<h3>Documenting state variables</h3>
<p>Declaring state variables is not necessary. You can simply attach them to nodes. But it should be pretty important
to declare them, in order to know what is available.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Something</span> |%<span class="hljs-variable">someState</span>| =&gt; {

}
</code></pre>
<h2>Optional keys</h2>
<p>:? =&gt; set le key value seulement si il y a une valeur</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = <span class="hljs-literal">null</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">obj</span> = {
 key:? <span class="hljs-variable">value</span>
}
<span class="hljs-variable">obj</span> === {} <span class="hljs-comment">// true</span>
<span class="hljs-string">&quot;key&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">obj</span> <span class="hljs-comment">// false</span>
</code></pre>
  <h2 id="scripts">Scripts</h2>
<p>In jome, the idea is that you could include most other programming languages directly using xml tags.</p>
<pre><code class="language-jome"><span class="hljs-comment">// Execute a shell command in a script</span>
<span class="language-shell">&lt;sh&gt;ls -A&lt;/sh&gt;</span>

<span class="hljs-comment">// Ruby is a pretty nice language for scripts too </span>
<span class="hljs-tag">&lt;<span class="hljs-name">rb</span>&gt;</span><span class="hljs-title function_">puts</span> (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-title function_">select</span>(&amp;:<span class="hljs-variable">even</span>?).<span class="hljs-variable">sum</span><span class="hljs-tag">&lt;/<span class="hljs-name">rb</span>&gt;</span>
</code></pre>
<p>Supported list for now:</p>
<ul>
<li>sh</li>
<li>html</li>
<li>md</li>
<li>js</li>
</ul>
<p>TODO list:</p>
<ul>
<li>css</li>
<li>bin</li>
<li>oct</li>
<li>hex</li>
<li>rb</li>
<li>sql</li>
<li>txt et/ou str</li>
<li>C</li>
<li>cpp</li>
</ul>
<p>MAYBE list:</p>
<ul>
<li>col: For color, need a way to let the editor know that we want to be picking a color.</li>
</ul>
<h3>Scripts for data</h3>
<p>TODO:</p>
<p>En jome, c'est <bin>01010101</bin> pour faire du binaire et <hex>FF00AA</hex> pour faire de l'hexadécimal.
<oct>12345678</oct> compile en 0o</p>
<p>Ne pas supporter 0xFF00AA et ne pas supporter non plus 0b01010101, ceci est confondant avec les unités.</p>
<p>bin et hex compile en utilisant 0x et 0b</p>
<p>TODO: Rajouter du syntax highligh au hex pour changer de couleur à toute les 2 charactères? Afficher comme des
string et à tous les 2 charactères mettre comme si escaped string pour que la couleur change un peu.</p>
<p>TODO: Supporter la syntaxe 123e4 par contre
let exponentialNumber = 123e4;
console.log(exponentialNumber); // Outputs: 1230000</p>
<h3>Scripts interpolation</h3>
<p>You can add data inside the scripts using the &lt; % =    % &gt; syntax.</p>
<p>Contrary to other template languages like ejs, you must finish the expression given inside the interpolation tag.</p>
<p>If you want to do a condition for example, you use a nesting tag &lt; &gt; ... &lt; / &gt;</p>
<pre><code class="language-jome">&lt; % = <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &lt; &gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
    &lt; % = <span class="hljs-variable">content</span> % &gt;
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-keyword">else</span> &lt; &gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
    &lt; % = <span class="hljs-variable">content</span> % &gt;
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
&lt; / &gt; % &gt;
</code></pre>
<p>The behavior will depend on the kind of script.</p>
<p>On html, it will insert a template literal interpolation.</p>
<p>On markdown what do I want to do?</p>
<p>Logically, it would include markdown. But this mean that some markdown would be compiled at compile time,
and that the text inside the interpolation would be compiled at run time. I don't like this because I don't
want the built file to include the javascript of markdown-it. But this could be a feature if that is actually
what the user want.</p>
<p>But right now, I am the user and this is not what I want. So what I want is that the text to be interpolated
be removed from the markdown compile, and that inserted compiled using a template literal.</p>
<p>Basically, I want to inject html and not inject markdown directly.</p>
<p>Nahhhh, I don't like this.</p>
<p>What I really what is to add markdown. This means using markdown-it at compile time. I am fine with this.</p>
<h3>Compile files with different extension</h3>
<p>You can compile files with a different extension by having the preceding extension just before.</p>
<p>So if you compile some-page.html.jome, it should first create a some-page.html.js, then this
file can be executed to make some-page.html</p>
<h3>.jobj extension</h3>
<p>Files with a .jobj extension would start already in a block.</p>
<p>It think this would be pratical for example for config files.</p>
  <h2 id="instance-driven-dev">Instance driven development</h2>
  Instance driven development is what I call when the focus is working on concrete objects in Godot software.
  Most of the time you control objects directly inside the editor and simply modify parameters.
<p>It's the same thing as object oriented, but the focus is on the concrete object rather than the abstract class.</p>
  <h2 id="units">Units</h2>
<pre><code class="language-jome"><span class="hljs-variable">debug</span> = |<span class="hljs-variable">arg</span>, <span class="hljs-keyword">unit</span> <span class="hljs-variable">argUnit</span>| =&gt; (
  <span class="hljs-comment">/* ... */</span>
)
</code></pre>
<p>You can add units at the end of numbers like 100g. You can also add units at the end of variables using the middle dot.</p>
<p>This feature is not yet implemented. Right now, it does nothing. The idea, is that if you have a function for example sleep
that takes a time, then you can give it 1s or 1000ms or 0.000ks and it would all do the same thing.</p>
<p>I want everything to be handled at compile time. I don't want to create a datastructure for this.</p>
<p>Also, it's just nice to be able to write a unit beside a number.</p>
<p>An idea also is that I would like to add an operator like variable-&gt;unit =&gt; which gives the unit has a string.
So this way, you have the number for the variable directly, but if the program can infer the unit of the variable,
you can also get it's unit.</p>
<p>density = 105g / 98mL
density-&gt;unit =&gt; &quot;g/mL&quot;</p>
<p>area = 2m * 3m
area-&gt;unit =&gt; &quot;m^2&quot;</p>
<p>maybe, for an argument to a function, well it could be anything, so you either specify what unit you are expecting,
or maybe have a special construct that means that you want the variable and it's unit</p>
<p>func = |anything| =&gt; anything-&gt;unit
func(10g)
// because we are asking for unit here, it means that two args must actually be passed to the function, anything and __unit__anything
so it would be compiled to
function func(anything, __unit__anything) {</p>
<p>}
func(10, &quot;g&quot;)</p>
<h2>signals</h2>
<p>Signals are used for events. They are not very much implemented yet. TODO: Check how Godot handles events, check how js handles events.</p>
<p>In Jome, signals start with a tilde.</p>
<pre><code class="language-jome"><span class="hljs-keyword">class </span><span class="hljs-title class_">Button</span> {
  ~<span class="hljs-title function_">click</span>() {
    <span class="hljs-variable">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>)
  }
}

<span class="hljs-variable">btn</span> = « <span class="hljs-variable">Button</span> »
<span class="hljs-variable">btn</span>.<span class="hljs-title function_">click</span>()
</code></pre>
<h3>Default signals</h3>
<p>Default signals are created for very common things.</p>
<p>Jome signals:</p>
<ul>
<li>~created: Called when an object is created. I think this would be soooo nice and would be very usefull.
This way, you can create an object and call a lot of methods that define how the object will be created.
Then it will be call automatically. Maybe objects will have a variable isAuto by default true and if true
then it will executed created automatically.</li>
</ul>
<p>Html functions:</p>
<p>click, ...</p>
<h3>Under the hood</h3>
<p>Work in progress</p>
<p>Signals are compiled as functions where the tilde is replaced by the prefix on_. And another
function is created with the same same as the signal to force the signal.</p>
<p>Or maybe just the version without the tilde and that's it?</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> {
  <span class="hljs-title function_">on_click</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>)
  }
  <span class="hljs-title function_">click</span>(<span class="hljs-params"></span>) { <span class="hljs-title function_">on_click</span>() }
  <span class="hljs-comment">// or simply</span>
  <span class="hljs-title function_">click</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>)
  }
}

btn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>()
btn.<span class="hljs-title function_">click</span>()
</code></pre>
  <h2 id="declaration">Declaration</h2>
<p>When you declare a variable without a keyword, the variable will be a constant. To declare a variable, use the var keyword.
To declare a function, use de def function.</p>
<p>TODO: Keywords, var, def, let</p>
<pre><code class="language-jome"><span class="hljs-variable">PI</span> = <span class="hljs-number">3.1415</span>
<span class="hljs-variable">PI</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// ERROR. PI is not allowed to be redeclared anywhere nested inside the scope</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable">x</span> = <span class="hljs-number">10</span>
<span class="hljs-variable">x</span> = <span class="hljs-number">20</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">add10</span> = <span class="hljs-variable">x</span> =&gt; <span class="hljs-variable">x</span> + <span class="hljs-number">10</span>
<span class="hljs-title function_">add10</span>(<span class="hljs-number">20</span>)
<span class="hljs-variable">add10</span> = <span class="hljs-variable">x</span> =&gt; <span class="hljs-variable">x</span> + <span class="hljs-number">20</span> <span class="hljs-comment">// ERROR. add10 can only be redeclared in a nested scope</span>
</code></pre>
<h2>along keyword</h2>
<p>When you want to also have the unit or the code for a variable, you can use the along keyword.</p>
<p>along is useful to be used alongside:</p>
<ul>
<li>unit: The unit of the expression given, as a string</li>
<li>type: The variable type of the expression given (like typescript), as a string</li>
<li>source: The source code literaly given of the expression, as a string</li>
<li>code: The js compiled code of the expression, as a string</li>
</ul>
<p>The along keyword is useful, because you could also want the use of the modifiers above alone.</p>
<p>def debug = |msg along code along type along unit| =&gt; (
def debug = |msg along code as customCodeName along type as customTypeName along unit as customUnitName| =&gt; (</p>
<p>You can't only get the modifier value, but then again you can simply assign an unused variable name</p>
<p>def printType = |unused along type|</p>
<h2>Capture de code</h2>
<p>TODO</p>
<p>Je pense que la syntaxe que je veux est d'utiliser le type 'code'.</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-variable">debug</span> = |<span class="hljs-variable">msg</span> <span class="hljs-variable">along</span> <span class="hljs-keyword">code</span>| =&gt; (
  <span class="hljs-built_in function_">#log</span>(<span class="hljs-keyword">code</span>+<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-variable">msg</span>)
)
<span class="hljs-title function_">debug</span>(<span class="hljs-variable">nomDeVariable</span>) <span class="hljs-comment">// =&gt; #log(&quot;nomDeVariable:&quot;, nomDeVariable)</span>

<span class="hljs-comment">// When calling in javascript, you need to supply both arguments</span>
<span class="hljs-title function_">debug</span>(<span class="hljs-variable">nomDeVariable</span>, <span class="hljs-string">&quot;nomDeVariable&quot;</span>)
</code></pre>
<h2>aka or alias</h2>
<p>I want to be able to give many possible names to a parameter.</p>
<p>For example, the port, it can be 'port' or 'p'</p>
<p>In js, you have to do:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">run</span> = (<span class="hljs-params">{port, p}</span>) =&gt; {
  port = port || p
}
</code></pre>
<p>In Jome, you can simply do:</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">run</span> = ({<span class="hljs-variable">port</span> <span class="hljs-variable">aka</span> <span class="hljs-variable">p</span>}) =&gt; {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>It will automatically be compiled to the code above.</p>
<h2>Strings</h2>
<p>Single and double quotes are to be the same and can be used interchangibly. Like in js and python.</p>
<p>Backticks are not to be supported for now. I don't know what I what to do with them.</p>
<p>All string are allowed to be multiline.</p>
<p>Ideas:</p>
<ul>
<li>&quot;Hello {name}!&quot; // name is interpolated with single {}</li>
<li>&quot;&quot;&quot;Hello {{name}}! Can use single &quot; or double &quot;&quot; inside too!&quot;&quot;&quot; // name is interpolated with double {{}}</li>
<li>@&quot;Hello {name}!
not escaped&quot; // verbatim,  only escapes the quote, no interpolation</li>
<li>@&quot;&quot;&quot;Hello  {{name}}!&quot;&quot;&quot; // verbatim,  only escapes the quote, but ALLOWS interpolation with double {{}}
Maybe:</li>
<li>#&quot;Hello #name! How are you #{name}? ##PI is almost 3.1416&quot; // #identifier and #{identifier} are both allowed for interpolation</li>
<li>$&quot;Hello ${name}!&quot; // exactly like backticks in js</li>
</ul>
<p>Maybe use ' and ''' instead of @&quot; and @&quot;&quot;&quot;? In ruby, this is what they do. It's just that I don't think it's that common.
And honestly I did not know that. @ is more explicit. Otherwise you might think they can be used interchangibly like in python.</p>
<h3>Formatting</h3>
<p>Formatting nomenclature:</p>
<p>x: trim
s: whole string
l: line
i: indent (trim, but keep indentation, check for least amount of spaces before, than trim, spaces and tabs not allowed combined, never with s (string))
t: tab
_: space
j: join (must be at the end of the format. joins all lines with the character after if any, or nothing if ends with j)</p>
<p>// Explicit characters like 	 and
are not trimmed.
&quot;&quot;%xs // Trim empty lines at the beginning of the string
&quot;&quot;%xsx // Trim empty lines at the beginning and the end of the string
&quot;&quot;%sx // Trim empty lines at the end of the string
&quot;&quot;%xl // Trim everyline before
&quot;&quot;%xlx // Trim everyline before and after
&quot;&quot;%lx // Trim everyline after
&quot;&quot;%xs%xt // Trim at the beginning of the string and the end of every line
&quot;&quot;%xl%sx // Trim at the beginning of every line and the end of the string
&quot;&quot;%i__ // Keep indentation at the beginning of everyline starting with two spaces</p>
<p>let description = &quot;This is a text description
on many lines. It stays many
lines but trims beginning.
&quot;%xlsx</p>
<p>let singleLine = &quot;This is written on multiple
lines but will all be joined
on a single line.
&quot;%xlx%j_</p>
<p>Maybe allow formatting after scripts too? <html></html>%xs</p>
<h3>Default string format</h3>
<p>I think I want the default format to be %i%xsx.</p>
<p>You can use the keyword <code>use</code> to set a default format for the strings that comes after in the current scope.</p>
<pre><code class="language-jome"><span class="hljs-variable">use</span> %<span class="hljs-variable">xlx</span>%<span class="hljs-variable">j_</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = <span class="hljs-string">&quot;some multi
           line string&quot;</span> <span class="hljs-comment">// will use the format above</span>
</code></pre>
<p>The formats do not add up to each other. When you specify a format, it replaces the previous one.</p>
<p>Maybe allow to give names to format that you can reuse?</p>
<p>Or simply numbers?</p>
<p>set format 0 %xlx%j_</p>
<p>then you do &quot;some string&quot;%0</p>
<p>When there is a default format and you want none, use only % like &quot;str&quot;%</p>
<p>Maybe define single digits aliases myself to be the most commonly used formats. This way you can know what it means without looking
it up if you are an expert.</p>
<p>Or maybe define named aliases myself.</p>
<p>%_html =&gt; string like in html, joins the lines with a single space</p>
<p>Maybe it would be nice if I could modify only some flag instead of all. Let's say, I always want xsx, but only sometimes xl,
I don't want to have to redefine xsx every time.</p>
<p>Peut-être quand dans le fond faire que ce sont tous des flags.</p>
<p>Tu peux faire %s pour reset string settings, %l pour line settings, %s%l%i%j équivalerais à % qui reset tout</p>
<p>Je ne sais pas pour %i par contre, mais celui n'est pas encore tout à fais clair. Ça garde juste le nested indent?</p>
<p>Si %i active, comment désactivé?</p>
  <h3 id="verbatim">Verbatim string literals</h3>
<p>Verbatim string literals are strings that do not interpolate. The idea is taken from C#. But in C# it also includes backslashes without escaping
them I don't know if I want to do that. Or I want to offer multiple possibilities.</p>
<pre><code class="language-jome"><span class="hljs-variable">str</span> = <span class="hljs-string">@&quot;This is a string that does ${not} interpolate&quot;</span>
</code></pre>
<h2>Threads</h2>
<p>Exactly the same as JavaScript? await, async, ...</p>
<pre><code class="language-jome"><span class="hljs-variable">async</span> <span class="hljs-keyword">def</span> <span class="hljs-variable">someMethod</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">let</span> <span class="hljs-variable">someFunc</span> = <span class="hljs-title function_">async</span> () =&gt; {x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>}
</code></pre>
<h2>Private</h2>
<p>For private fields inside classes, you can use a private block.
You can also use the private before a method.</p>
<pre><code>class SomeClass
  private
    def somePrivateMethod
    end
  end

  private def someOtherPrivateMethod
  end
end
</code></pre>
<p>It compiles in javascript using a # before the names of fields.</p>
<h2>Main</h2>
<p>The <code>main</code> keyword is compiled to <code>export default</code>.</p>
<p>Waiiiiiiit. Pas sur. Je vais convertir mes trucs en CommonJs, et on va voir après si je peux supporter ça.</p>
<p>Possiblement tu peux faire main ou export, mais pas les deux en même temps, parce que sois tu exécutes, sois tu exportes des fonctions
parce que tu ne peux pas avoir l'équivalent de export et export default en CommonJS je crois.</p>
<h3>Export</h3>
<p>Au lieu de export, le keyword public?</p>
<p>Une idée: Tous est export par défault. Pour mettre privé, mettre un underscore au début.</p>
<p>Ça pourrait être une option de compilation optionelle. (enabled on mode prototypage, disabled en mode securité?)</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-variable">publicFunc</span> = =&gt; (

)

<span class="hljs-keyword">def</span> <span class="hljs-variable">_privateFunc</span> = =&gt; (
  
)
</code></pre>
<h3>Ternary</h3>
<p>Idée: pas de ternary operator comme d'habitude, parce que je veux pouvoir faire (x ? y) seulement
sans le :. Le : est très utilisé je trouve. Je n'ai pas tant envie de l'utiliser comme opérateur simple.
L'idée est donc d'utiliser les opérateurs qui existe déjà, ? et ??.
x ? y ?? z
Si x, alors y, sinon z
D'un côté je n'aime pas dévié d'un standard. ? : est pas mal dans tous les languages, mais d'un autre côté
je trouve ça vraiment gossant de ne pas pouvoir faire simplement x ? y. Le résultat serait null.
let r = x ? y // si x, alors y, sinon null
let r = x if y // si x, alors y, sinon undefined
let r = <code>{x ? y}</code> // si x, alors <code>{y}</code>, sinon <code>null</code>
let r = <code>{x if y}</code> // si x, alors <code>{y}</code>, sinon `` J'aimerais vraiment ça!!!!!!!!!!!!!!</p>
<h2>Environment variables</h2>
<p>Use #env for environment variables</p>
<pre><code class="language-jome"><span class="hljs-built_in variable_">#env</span>.<span class="hljs-variable">MY_ENV_VAR</span> = <span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-comment">// =&gt; process.env.MY_ENV_VAR = &#x27;foo&#x27;</span>
</code></pre>
<h2>Global variables</h2>
<p>Global variables start with a dollar sign. For example, <code>$MY_GLOB_VAR = 'foo'</code>.</p>
<p>Simply equivalent of global._ for now. Adding underscore in order to avoid name clashes. For example,
I was using $URL, but this does not work because global.URL already exists within Node.</p>
<h2>Pretty output</h2>
<p>Idéalement, je ne me soucis pas de l'indentation de l'output et tout le tralala qui peut compliquer le compilateur pour rien.</p>
<p>Simplement passer le code dans un formatteur de code.</p>
<p>J'ai essayé prettier et js-beautify.</p>
<p>Je préfère de loin prettier je trouve son output plus beau personnellement.</p>
<p>Le problème est que prettier bug et ne veut pas process mes fichiers s'ils sont dans le .gitignore file............</p>
<h2>TODO</h2>
<p>Faire que this fais toujours référence à un this normal!!! Caché ce défault de javascript de l'utilisateur.</p>
<p>Peut-être créer un keyword #evt ou quelque chose du genre pour avoir accès au this dans un évènement html.</p>
<p>Idée: #1, #2, ... fait référence aux arguments d'une fonction. Pas obliger de les déclarer. Ça peut être court comme syntaxe
pour des filters par exemple.</p>
<pre><code class="language-jome"><span class="hljs-keyword">let</span> <span class="hljs-variable">even</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-built_in function_">#1</span> <span class="hljs-variable">mod</span> <span class="hljs-number">2</span>)
</code></pre>
<p>TODO: Try an idea: -&gt; and =&gt; are optional</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-variable">addXY</span> = |<span class="hljs-variable">x</span>, <span class="hljs-variable">y</span>| (<span class="hljs-variable">x</span> + <span class="hljs-variable">y</span>)
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>].<span class="hljs-title function_">filter</span>(|<span class="hljs-variable">nb</span>| <span class="hljs-variable">nb</span> &gt; <span class="hljs-number">5</span>)
<span class="hljs-comment">// Et pour quand il n&#x27;y a pas d&#x27;argument?</span>
<span class="hljs-keyword">def</span> <span class="hljs-variable">sayHello</span> = | | (<span class="hljs-built_in function_">#log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)) <span class="hljs-comment">// Noooooon ça c&#x27;est laid...</span>
</code></pre>
<p>get and set javascript keyword? Allow this in Jome? Or should use -&gt;?</p>
<p>Je viens d'apprendre qu'il existe le keyword get en javascript qui permet de faire ça.
Mais l'avantage d'utiliser un -&gt; est que tu peux définir une méthode avec des arguments optionels.
C'est impossible avec get. (A getter must have exactly zero parameters)</p>
<h2>Contributing</h2>
<p>I recommend using visual studio code for now because it is super usefull for debugging tokenization. You hit Ctrl+Shift+P,
&quot;inspect editor token and scope&quot;, and you see if it is correct. Also you see using syntax highlighting.</p>
<p>You can make pull requests on github.</p>
<p>You can simply make constructive comments on github.</p>
<p>Keep in mind I am working only 10 hours a week on this project for now.</p>
<h2>Acknowledgements</h2>
<p>TODO: Explain why</p>
<ul>
<li>CoffeeScript: I was kinda lost at some point. I did not have a clear direction for my language. Until I thought, hey, coffeescript did something similar! So it gave me a lot of guidance.</li>
<li>underscore.js: A great library full of goodies.</li>
<li>vscode: Escpecially thank you for creating custom grammar. It is really nice to create a grammar and see live the tokenization.</li>
<li>ChatGPT: I probably never would have had to courage to go through with writing a programming language if I did not have the help from ChatGPT.</li>
</ul>
<p>Thank you to everyone who contributed to any open-sourced library. Escpecially under a license like MIT license. You are awesome!</p>
<p>TODO: Link to the librairies website</p>
<p>Librairies used:</p>
<ul>
<li>express</li>
<li>markdown-it</li>
</ul>
<h2>Thrash</h2>
<p>It's intented main purpose is to be used for prototyping or small projects. It is usefull for concrete applications like making something visual.</p>
<pre><code>«
Page
  Navbar
    List
      Link &quot;Musics&quot;, to: '/musics'
      Link &quot;Sports&quot;, to: '/sports'
      Link &quot;Arts&quot;, to: '/arts'
  Body
    Txt &lt; md &gt;
      # Welcome
      Welcome to this website! You can browse links at the top.
    &lt; / md&gt;
</code></pre>
<p>»</p>
<pre><code>Il est aussi possible de définir des variables dans un bloc. Les variables sont simplement sorties du block et exécuter avant le bloc.
</code></pre>
<p>Avoir un keyword new ou ben simplement toujours utiliser les blocks?</p>
<pre><code class="language-jome"><span class="hljs-variable">obj</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">Obj</span>(<span class="hljs-comment">/* ... */</span>) <span class="hljs-comment">// Supporter new?</span>
<span class="hljs-variable">obj</span> = {<span class="hljs-variable">Obj</span> <span class="hljs-comment">/* ... */</span>}
</code></pre>
<p>The advantage is that there is never confusion. You never have an error that tells you you have to add parentheses. For example, in javascript:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">someFunction</span> = (<span class="hljs-params"></span>) =&gt; ({<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>}) <span class="hljs-comment">// you often have to add extra parentheses around objects in js</span>
</code></pre>
<pre><code class="language-jome"><span class="hljs-comment">// lists</span>
<span class="hljs-variable">numbers</span> = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>} <span class="hljs-comment">// but [1,2,3,4] is preferred when on a single line</span>
<span class="hljs-variable">names</span> = {
  <span class="hljs-string">&quot;Jean&quot;</span>
  <span class="hljs-string">&quot;Jacques&quot;</span>
  <span class="hljs-string">&quot;Paul&quot;</span>
}
<span class="hljs-variable">matrix</span> = {
  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
  <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
}
</code></pre>
<h2>Features</h2>
<p>Main ideas:</p>
<ul>
<li><a href="#nodes">Nodes</a> - An object in a tree structure</li>
<li><a href="#integrated-scripts">Integrated scripts</a> - Incoroporate code from other languages</li>
<li><a href="#named-parameters">Named parameters and props</a> - Add optional parameters easily</li>
<li><a href="#instance-driven-dev">Instance driven development</a> - A more approchable way to programming</li>
</ul>
<p>Goodies / Syntaxic sugar:</p>
<ul>
<li><a href="#arrow-getter">Arrow getter</a> - Allows to save keystrokes and is easier to type. ex: obj-&gt;keys =&gt; Object.keys(obj)</li>
<li>Optional let - Not sure about that one...</li>
<li><a href="#verbatim">Verbatim string literals</a> - @<code>This is a string that does ${not} interpolate</code></li>
<li><a href="#units">Units</a> - You can add units to numbers. ex: &quot;density = 105g / 98mL&quot;</li>
<li><a href="#hyphens">Hyphen</a> - You can use hyphens in variable names like left-panel. The minus operator should always be surrounded by spaces.</li>
</ul>
<p>Pouvoir caller une fonction locale comme .#, en utilisant .: ? arg.:funcLocal</p>
<h2>bugs</h2>
<p>FIXME: The indentation is super important in markdown. For example, adding tabs inside md scripts, if only one tab html tags will work,
otherwise it will not.</p>
<h1>DEPRECATED</h1>
  <h2 id="named-parameters">Named parameters and props</h2>
<p>When calling a function, you can add paramters.</p>
<pre><code class="language-jome"><span class="hljs-title function_">someFunc</span>(someParam: <span class="hljs-number">10</span>, otherParam: <span class="hljs-string">&#x27;Jean&#x27;</span>)
</code></pre>
<p>To define parameters when creating a function, you either add ? at the end for an optional parameter, or you add ! for a required parameter.</p>
<pre><code class="language-jome"><span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span> = |<span class="hljs-variable">someParam</span>?, <span class="hljs-variable">otherParam</span>? = <span class="hljs-string">&#x27;Pierre&#x27;</span>, <span class="hljs-variable">optionalParam</span>?, <span class="hljs-variable">requiredParam</span>!| =&gt; (
  <span class="hljs-variable">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable">someParam</span>) <span class="hljs-comment">// No need to add ? or ! when refering to a parameter</span>
)
</code></pre>
<p>You can pass a parameter that was not defined in the list.</p>
<p>BUT YOU CAN'T PASS a parameter to a function if the function does not take any parameter. Because under the hood,
we add a params argument to the function, so we need at least one to add the argument, then you can pass as many as you want.</p>
<p>When calling a function with named parameters, the order does not matter. You can put them before arguments, after or even in the middle.</p>
<h3>PARAMS</h3>
<p>Get the list of parameters given to a function.</p>
<pre><code class="language-jome">  <span class="hljs-keyword">def</span> <span class="hljs-variable">someFunc</span> = =&gt; (
    <span class="hljs-variable">PARAMS</span> <span class="hljs-comment">// The object containing all the paramters given to the function.</span>
  )  
</code></pre>
<p>FIXME: I don't like using the word PARAMS in capital letters, but I don't have a better idea yet.
I don't want to reserve the keyword params...</p>
<p>Use #params instead of PARAMS?</p>
<h3>Props</h3>
<p>Props are all the parameters and attributes as parameters passed during an object creation.</p>
<pre><code class="language-jome">« <span class="hljs-variable">Obj</span> someProp: <span class="hljs-number">10</span>, someAttr: <span class="hljs-string">&#x27;Paul&#x27;</span> »
<span class="hljs-keyword">class </span><span class="hljs-title class_">Obj</span> |<span class="hljs-variable">someProp</span>?, <span class="hljs-variable">@someAttr</span>?| =&gt; {
}
<span class="hljs-comment">// compiles to</span>
<span class="hljs-keyword">class </span><span class="hljs-title class_">Obj</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-variable">__props__</span>) {
    <span class="hljs-variable">this</span>.<span class="hljs-variable">__props__</span> = <span class="hljs-variable">__props__</span>
    <span class="hljs-keyword">let</span> {<span class="hljs-variable">someAttr</span>, ...<span class="hljs-variable">__params___</span>} = <span class="hljs-variable">__props__</span>
    <span class="hljs-variable">this</span>.<span class="hljs-variable">__params__</span> = <span class="hljs-variable">__params__</span>
    <span class="hljs-variable">this</span>.<span class="hljs-variable">someAttr</span> = <span class="hljs-variable">someAttr</span>
  }
}
</code></pre>
<h3>Under the hood</h3>
<p>TODO: Explain how it works</p>
<h3>Instantiation</h3>
<p>I would like to create an instance by calling just like a function. SomeClass() // which would become new SomeClass()</p>
<p>I want to use the new keyword, because it binds this and when you call a function or a class constructor using new, it creates an empty object, sets the object's prototype to the prototype property of the constructor, and executes the constructor to initialize the object.</p>
<p>The ideal would be to know the type. Basically, when it is local I know what it refers to. The issue is imports. I don't want
to have to read the files to know what it is.</p>
<p>Using capital letters is a convention, but I don't want to use this.</p>
<p>I think the best to have a syntax when importing that differentiates between classes and functions.</p>
<p>Wait this does not work, because functions can be called and they can be created using new.</p>
<p>Simply always use new inside blocks?</p>
<h2>Work in progress</h2>
<p>identifier // new identifier()
.identifier // call identifier on the created object
key: identifier // pass identifier to the constructor as a property of the object
=identifier // add identifier as a children of the node
key = identifier // add identifier as a property of the object and as a children</p>
<p>// if you want to set attributes without passing it to the constructor, you can use:
.set attr: 'value' // set is a method on Node</p>
<p>Le désavantage que je vois de faire key: identifier pour une propriété, est que c'est tanant pour le type.
Avec un = c'est facile rajouter le type. Mais d'un autre côté, est-ce qu'on veut vraiment mettre un type
là? Ça devrait être assez explicit en général. Et tu peux quand même le faire avec [key: type].</p>
<p>You can specify dynamic keys using square brackets. Ex: [<code>key_{name}</code>]</p>
<pre><code class="language-jome">{
<span class="hljs-variable">Recipe</span>
  name: <span class="hljs-string">&#x27;Chickpea balls&#x27;</span>
  prepare: <span class="hljs-number">1h</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">1cup</span>, <span class="hljs-string">&quot;dry chickpeas&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2cup</span>, <span class="hljs-string">&quot;water&quot;</span>
  <span class="hljs-variable">Ing</span> <span class="hljs-number">2tbsp</span>, <span class="hljs-string">&quot;parmesan&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">`Put {@1} into {@2}...`</span> <span class="hljs-comment">// @1 is the first children</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Mix ...&quot;</span>
  <span class="hljs-variable">Step</span> <span class="hljs-string">&quot;Blah blah ...&quot;</span>
  .<span class="hljs-variable">prepare</span> <span class="hljs-string">&#x27;The recipe&#x27;</span>
  <span class="hljs-variable">Ing</span> ...
}
</code></pre>
<pre><code class="language-jome"><span class="hljs-comment">// Three syntaxes allowed to execute functions</span>
{[
  <span class="hljs-variable">Obj</span> prop: <span class="hljs-string">&#x27;val&#x27;</span>
    .<span class="hljs-variable">execFunc</span>
    .<span class="hljs-variable">execFunc2</span>

  <span class="hljs-variable">Obj</span> prop: <span class="hljs-string">&#x27;val&#x27;</span> <span class="hljs-variable">exec</span>
    <span class="hljs-variable">execFunc</span>
    <span class="hljs-variable">execFunc2</span>

  <span class="hljs-variable">Obj</span> prop: <span class="hljs-string">&#x27;val&#x27;</span>
    <span class="hljs-variable">exec</span>
      <span class="hljs-variable">execFunc</span>
      <span class="hljs-variable">execFunc2</span>
]}
</code></pre>
<pre><code class="language-jome"><span class="hljs-comment">// Create a server, add a get handler and start it</span>
{
  <span class="hljs-variable">ExpressServer</span> port: <span class="hljs-number">3000 exec</span>
    <span class="hljs-variable">get</span> <span class="hljs-string">&#x27;/&#x27;</span>, |<span class="hljs-variable">req</span>, <span class="hljs-variable">res</span>| =&gt; (
      <span class="hljs-variable">res</span>.<span class="hljs-title function_">send</span>(<span class="hljs-variable">homePage</span>)
    )
    <span class="hljs-variable">start</span>
}
</code></pre>

              </div>
            </div>
          </div>
        </body>
      </HTML>
    